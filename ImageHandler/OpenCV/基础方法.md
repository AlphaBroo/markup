# 基础方法

## 安装使用

```shell
# 安装
pip install python-opencv
# 使用
import cv2 as cv
```

## 基础使用

- 载入

```python
cv.imread(path)
# 将图片载入到内存中
# 返回ndarry类型的图像数据
# 参数
path	图片路径
```

- 显示

```python
cv.imshow(name, img)
# 在名字为name的窗口中显示img图像
```

- 保存

```python
cv.iwrite(path, img,)
# 将图像img写入到硬盘的path路径中
```
-  图像属性
```python
img.shape  # 图像高、宽、通道数组成的元组
img.size  # 图像高*宽*通道数
img.dtype  # unit8
```
示例

```python
import cv2 as cv
import numpy as np

# 读取载入图片
img = cv.imread("./cat.jpg")
# 创建图片
emptyImage = np.zeros(img.shape, np.uint8)
# 复制图片
emptyImage2 = img.copy()
# 获得原图片灰度化后的图片 
emptyImage3=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
#emptyImage3[...]=0  # 将其转成空白的黑色图像
 
cv.imshow("EmptyImage", emptyImage)  # 展示图像
cv.namedWindow("Image")  # 新建重命名的窗口
cv.imshow("Image", img)  # 展示图像
cv.imshow("EmptyImage2", emptyImage2)
cv.imshow("EmptyImage3", emptyImage3)
cv.imwrite("./cat1.jpg", img)  # 保存图像，参数1：路径，参数2：图像数据
cv.imwrite("./cat2.jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 5])  # 参数3：图像质量0~100，默认5
cv.imwrite("./cat3.jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 100])
cv.imwrite("./cat.png", img, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])  # 参数3：压缩级别0~9， 默认3
cv.imwrite("./cat2.png", img, [int(cv2.IMWRITE_PNG_COMPRESSION), 9])
cv.waitKey (0)
cv.destroyAllWindows()  # 销毁所有窗口
```

## 像素处理
###  像素操作
像素的访问和访问numpy中ndarray的方法完全一样
```python
# 灰度图
img[j, i] = 255  # j,i分别表示图像的行和列
# BGR图像
img[j,i,0]= 255  # 0通道
img[j,i,1]= 255  # 1通道
img[j,i,2]= 255  # 2通道
```
像素取反

```python
# 方法一：
def access_pixels(image):
    # height = image.shape[0]
    # width = image.shape[1]
    # channels = image.shape[2]
    height, width, channels = img.shape
    print("width : %s, height : %s channels : %s"%(width, height, channels))
    # 像素遍历取反，速度较慢
    for row in range(height):
        for col in range(width):
            for c in range(channels):
                pv = image[row, col, c]
                image[row, col, c] = 255 - pv
    cv.imshow("pixels_demo", image
              
# 方法二：
def inverse(image):
    """像素取反内部api，速度快"""
    dst = cv.bitwise_not(image)
    cv.imshow("inverse demo", dst
```

创建图像

```python
def create_image():
		# numpy操作  
    m1 = np.ones([3, 3], np.uint8)
    m1.fill(12222.388)  # 溢出截断
    print(m1)

    m2 = m1.reshape([1, 9])  # 调整数组维度
    print(m2)

    m3 = np.array([[2,3,4], [4,5,6],[7,8,9]], np.int32)  # 直接指定值
    #m3.fill(9)
    print(m3)

    # 创建图片
    img = np.zeros([400, 400, 3], np.uint8)
    #img[: , : , 0] = np.ones([400, 400])*255
    img[:, :, 2] = np.ones([400, 400]) * 255
    cv.imshow("new image", img)

    img = np.ones([400, 400, 1], np.uint8)
    img = img * 0
    cv.imshow("new image", img)
    cv.imwrite("D:/myImage.png", img)
```

人工添加椒盐

```python
import cv2
import numpy as np
 
def salt(img, n):
	for k in range(n):
        # np.random.random()随机数生成，比python中的random()拥有更多方法，但是非线程安全；若需要使用多线程，使用python自带的random()或构建一个本地的np.random.Random类的实例
		i = int(np.random.random() * img.shape[1]);
		j = int(np.random.random() * img.shape[0]);
		if img.ndim == 2:  # 灰度图像 
			img[j,i] = 255
		elif img.ndim == 3:  # BGR图像 
			img[j,i,0]= 255
			img[j,i,1]= 255
			img[j,i,2]= 255
	return img
 
if __name__ == '__main__':
	img = cv2.imread("图像路径")
	saltImage = salt(img, 500)
	cv2.imshow("Salt", saltImage)
	cv2.waitKey(0)
	cv2.destroyAllWindows()
```
### 像素运算

- 算数运算

```python
# 相加
dst = cv.add(m1, m2) 
# 相减  
dst = cv.subtract(m1, m2)
# 相乘
dst = cv.multiply(m1, m2)
# 相除
dst = cv.divide(m1, m2)  
```

- 逻辑运算

```python
# 与
dst = cv.bitwise_and(m1, m2)
# 或
dst = cv.bitwise_or(m1, m2)  
# 非
dst = cv.bitwise_not(image)
```

增加亮度和对比度

```python
def contrast_brightness_demo(image, c, b):
    h, w, ch = image.shape
    blank = np.zeros([h, w, ch], image.dtype)
    dst = cv.addWeighted(image, c, blank, 1-c, b)  # 增加对比度和亮度
    cv.imshow("con-bri-demo", dst)
    
contrast_brightness_demo(src, 1.5, 0)
```

对比度表征

```python
# 均值，表示了整体的亮度
# 方差，表征了对比度
M1, dev1 = cv.meanStdDev(m1)  
M2, dev2 = cv.meanStdDev(m2)
h, w = m1.shape[:2]
print(M1)
print(M2)
print(dev1)
print(dev2)

img = np.zeros([h, w], np.uint8)
m, dev = cv.meanStdDev(img)
print(m)
print(dev)
```



### 通道分离

可以使用OpenCV自带的split函数(推荐)，也可以直接操作numpy数组来分离通道
```python
import cv2
import numpy as np
 
img = cv2.imread("D:/cat.jpg")
# opencv
b, g, r = cv2.split(img)  # 三个通道同时分离
b = cv2.split(img)[0]  # b单通道
g = cv2.split(img)[1]  # g单通道
r = cv2.split(img)[2]  # r单通道
# numpy
b = np.zeros((img.shape[0],img.shape[1]), dtype=img.dtype)
g = np.zeros((img.shape[0],img.shape[1]), dtype=img.dtype)
r = np.zeros((img.shape[0],img.shape[1]), dtype=img.dtype)
b[:,:] = img[:,:,0]
g[:,:] = img[:,:,1]
r[:,:] = img[:,:,2]

cv2.imshow("Blue", r)
cv2.imshow("Red", g)
cv2.imshow("Green", b)
cv2.waitKey(0)
```
### 通道合并

通道合并也有两种方法，实际使用时请用OpenCV自带的merge函数！用NumPy组合的结果不能在OpenCV中其他函数使用，因为其组合方式与OpenCV自带的不一样
```python
import cv2
import numpy as np
 
img = cv2.imread("D:/cat.jpg")
 
b, g, r = cv2.split(img)  # 三个通道同时分离
# opencv
merged = cv2.merge([b,g,r])
print merged.strides  # 表示的是在每个维数上以字节计算的步长
# numpy
mergedByNp = np.dstack([b,g,r]) 
print mergedByNp.strides
 
cv2.imshow("Merged", merged)
cv2.imshow("MergedByNp", merged)
cv2.imshow("Blue", b)
cv2.imshow("Red", r)
cv2.imshow("Green", g)
cv2.waitKey(0)
```
## 图像转换

- 色彩空间

BGR

```

```

灰度化

```

```

HSV

```
H:0~180
S:0~255
V:0~255
```

|      | 黑   | 灰   | 白   | 红   | 红   | 橙   | 黄   | 绿   | 青   | 蓝   | 紫   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| hmin | 0    | 0    | 0    | 0    | 156  | 11   | 26   | 35   | 78   | 100  | 125  |
| hmax | 180  | 180  | 180  | 10   | 180  | 25   | 34   | 77   | 99   | 124  | 155  |
| smin | 0    | 0    | 0    | 43   | 43   | 43   | 43   | 43   | 43   | 43   | 43   |
| smax | 255  | 43   | 30   | 255  | 255  | 255  | 255  | 255  | 255  | 255  | 255  |
| vmin | 0    | 46   | 221  | 46   | 46   | 46   | 46   | 46   | 46   | 46   | 46   |
| vmax | 46   | 220  | 255  | 255  | 255  | 255  | 255  | 255  | 255  | 255  | 255  |

YUV

```

```

YCrCb

```

```

API

```python
# BGR转灰度
gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)  
# BGR转HSV
hsv = cv.cvtColor(image, cv.COLOR_BGR2HSV)  
# BGR转YUV  
yuv = cv.cvtColor(image, cv.COLOR_BGR2YUV)  
# BGR转YCrCb
Ycrcb = cv.cvtColor(image, cv.COLOR_BGR2YCrCb)  
```

示例

```python
# 视频中绿色图像追踪
def extrace_object_demo():
    capture = cv.VideoCapture("D:/vcprojects/images/video_006.mp4")
    while(True):
        ret, frame = capture.read()
        if ret == False:
            break;
        hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)  # 转换程HSV
        lower_hsv = np.array([35, 43, 46])  # 低经验值
        upper_hsv = np.array([77, 255, 255])  # 高经验值
        mask = cv.inRange(hsv, lowerb=lower_hsv, upperb=upper_hsv)  # 绿色对象提取追踪
        dst = cv.bitwise_and(frame, frame, mask=mask)  # 将二值化后的图像与原图相加，求取绿色图像
        cv.imshow("video", frame)
        cv.imshow("mask", dst)
        c = cv.waitKey(40)
        if c == 27:
            break
```

