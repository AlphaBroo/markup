# 基础方法

## 安装

```shell
pip install python-opencv
```

## 载入显示和保存
```python

import cv2
import numpy as np

# 读取载入图片
img = cv2.imread("./cat.jpg")
# 创建图片
emptyImage = np.zeros(img.shape, np.uint8)
# 复制图片
emptyImage2 = img.copy()
# 获得原图片灰度化后的图片 
emptyImage3=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
#emptyImage3[...]=0  # 将其转成空白的黑色图像
 
cv2.imshow("EmptyImage", emptyImage)  # 展示图像
cv2.namedWindow("Image")  # 新建重命名的窗口
cv2.imshow("Image", img)  # 展示图像
cv2.imshow("EmptyImage2", emptyImage2)
cv2.imshow("EmptyImage3", emptyImage3)
cv2.imwrite("./cat1.jpg", img)  # 保存图像，参数1：路径，参数2：图像数据
cv2.imwrite("./cat2.jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 5])  # 参数3：图像质量0~100，默认5
cv2.imwrite("./cat3.jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 100])
cv2.imwrite("./cat.png", img, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])  # 参数3：压缩级别0~9， 默认3
cv2.imwrite("./cat2.png", img, [int(cv2.IMWRITE_PNG_COMPRESSION), 9])
cv2.waitKey (0)
cv2.destroyAllWindows()  # 销毁所有窗口
```
- 图像属性
```python
img.shape  # 图像高、宽、通道数组成的元组
img.size  # 图像高*宽*通道数
img.dtype  # unit8
```
## 元素访问通道分离合并
###  元素访问
像素的访问和访问numpy中ndarray的方法完全一样
```python
# 灰度图
img[j, i] = 255  # j,i分别表示图像的行和列
# BGR图像
img[j,i,0]= 255  # 0通道
img[j,i,1]= 255  # 1通道
img[j,i,2]= 255  # 2通道
```
人工添加椒盐
```python
import cv2
import numpy as np
 
def salt(img, n):
	for k in range(n):
        # np.random.random()随机数生成，比python中的random()拥有更多方法，但是非线程安全；若需要使用多线程，使用python自带的random()或构建一个本地的np.random.Random类的实例
		i = int(np.random.random() * img.shape[1]);
		j = int(np.random.random() * img.shape[0]);
		if img.ndim == 2:  # 灰度图像 
			img[j,i] = 255
		elif img.ndim == 3:  # BGR图像 
			img[j,i,0]= 255
			img[j,i,1]= 255
			img[j,i,2]= 255
	return img
 
if __name__ == '__main__':
	img = cv2.imread("图像路径")
	saltImage = salt(img, 500)
	cv2.imshow("Salt", saltImage)
	cv2.waitKey(0)
	cv2.destroyAllWindows()
```
### 通道分离

可以使用OpenCV自带的split函数(推荐)，也可以直接操作numpy数组来分离通道
```python
import cv2
import numpy as np
 
img = cv2.imread("D:/cat.jpg")
# opencv
b, g, r = cv2.split(img)  # 三个通道同时分离
b = cv2.split(img)[0]  # b单通道
g = cv2.split(img)[1]  # g单通道
r = cv2.split(img)[2]  # r单通道
# numpy
b = np.zeros((img.shape[0],img.shape[1]), dtype=img.dtype)
g = np.zeros((img.shape[0],img.shape[1]), dtype=img.dtype)
r = np.zeros((img.shape[0],img.shape[1]), dtype=img.dtype)
b[:,:] = img[:,:,0]
g[:,:] = img[:,:,1]
r[:,:] = img[:,:,2]

cv2.imshow("Blue", r)
cv2.imshow("Red", g)
cv2.imshow("Green", b)
cv2.waitKey(0)
```
### 通道合并

通道合并也有两种方法，实际使用时请用OpenCV自带的merge函数！用NumPy组合的结果不能在OpenCV中其他函数使用，因为其组合方式与OpenCV自带的不一样
```python
import cv2
import numpy as np
 
img = cv2.imread("D:/cat.jpg")
 
b, g, r = cv2.split(img)  # 三个通道同时分离
# opencv
merged = cv2.merge([b,g,r])
print merged.strides  # 表示的是在每个维数上以字节计算的步长
# numpy
mergedByNp = np.dstack([b,g,r]) 
print mergedByNp.strides
 
cv2.imshow("Merged", merged)
cv2.imshow("MergedByNp", merged)
cv2.imshow("Blue", b)
cv2.imshow("Red", r)
cv2.imshow("Green", g)
cv2.waitKey(0)
```
## 直方图
### 计算显示
```python
cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate ]]) 
# 返回hist
# 参数
images  # 图像的list,如[img]
channels  # 用于计算直方图的通道list，灰度图像[0],BGR图像则
mask  # 遮罩层，可为None
histSize  # 表示这个直方图分成多少份，一般为[256]
ranges  # 表示直方图中各个像素的值，[0.0, 256.0]表示直方图能表示像素值从0.0到256的像素
hist
accumulate  # 可选，表示直方图是否叠加
```
彩色图像不同通道的直方图
```python
import cv2    
import numpy as np    
    
img = cv2.imread("D:/lena.jpg")    
b, g, r = cv2.split(img) 
histImgB = calcAndDrawHist(b, [255, 0, 0])  
histImgG = calcAndDrawHist(g, [0, 255, 0])  
histImgR = calcAndDrawHist(r, [0, 0, 255])  
    
cv2.imshow("histImgB", histImgB)  
cv2.imshow("histImgG", histImgG)  
cv2.imshow("histImgR", histImgR)  
cv2.imshow("Img", img)  
cv2.waitKey(0)  
cv2.destroyAllWindows()

def calcAndDrawHist(image, color):  
    hist= cv2.calcHist([image], [0], None, [256], [0.0,255.0])  
    minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(hist)  
    histImg = np.zeros([256,256,3], np.uint8)  
    hpt = int(0.9* 256);  
      
    for h in range(256):  
        intensity = int(hist[h]*hpt/maxVal)  
        cv2.line(histImg,(h,256), (h,256-intensity), color)  
          
    return histImg; 

```
无需分离通道，用折线来描绘直方图的边界可在一副图中同时绘制三个通道的直方图
```python
#coding=utf-8  
import cv2  
import numpy as np  
       
img = cv2.imread('D:/lena.jpg')  
h = np.zeros((256,256,3)) #创建用于绘制直方图的全0图像  
       
bins = np.arange(256).reshape(256,1) #直方图中各bin的顶点位置  
color = [ (255,0,0),(0,255,0),(0,0,255) ] #BGR三种颜色  
for ch, col in enumerate(color):  
    originHist = cv2.calcHist([img],[ch],None,[256],[0,256])  
    cv2.normalize(originHist, originHist,0,255*0.9,cv2.NORM_MINMAX)  # 归一化
    hist=np.int32(np.around(originHist))  # 将生成的原始直方图中的每个元素四舍六入五凑偶取整（cv2.calcHist函数得到的是float32类型的数组），接着将整数部分转成np.int32类型
    pts = np.column_stack((bins,hist))  # 将直方图中每个bin的值转成相应的坐标
    cv2.polylines(h,[pts],False,col)  # 根据这些点绘制出折线，第三个False参数指出这个折线不需要闭合。第四个参数指定了折线的颜色。
       
h=np.flipud(h)  # 反转绘制好的直方图，因为绘制时，[0,0]在图像的左上角
       
cv2.imshow('colorhist',h)  
cv2.waitKey(0)  
```
numpy版的直方图
```python
#coding=utf-8
import cv2
import numpy as np
 
img = cv2.imread('D:/lena.jpg')
h = np.zeros((300,256,3))
bins = np.arange(257)
bin = bins[0:-1]
color = [ (255,0,0),(0,255,0),(0,0,255) ]
 
for ch,col in enumerate(color):
	item = img[:,:,ch]
	N,bins = np.histogram(item,bins)
	v=N.max()
	N = np.int32(np.around((N*255)/v))
	N=N.reshape(256,1)
	pts = np.column_stack((bin,N))
	cv2.polylines(h,[pts],False,col)
 
h=np.flipud(h)
 
cv2.imshow('img',h)
cv2.waitKey(0)
```
### 查找表拉伸直方图
[参考](https://blog.csdn.net/sunny2038/article/details/9403059)
在图像处理中，直方图均衡化一般用来均衡图像的强度，或增加图像的对比度。在介绍使用直方图均衡化来拉伸图像的直方图之前，先介绍使用查询表的方法。

观察上图中原始图像的直方图，很容易发现大部分强度值范围都没有用到。因此先检测图像非0的最低（imin）强度值和最高（imax）强度值。将最低值imin设为0，最高值imax设为255。中间的按255.0*(i-imin)/(imax-imin)+0.5)的形式设置

```python
#coding=utf-8
import cv2
import numpy as np
 
image = cv2.imread("D:/test/unequ.jpg", 0)
lut = np.zeros(256, dtype = image.dtype )#创建空的查找表
hist= cv2.calcHist([image], #计算图像的直方图
    [0], #使用的通道
    None, #没有使用mask
    [256], #it is a 1D histogram
    [0.0,255.0])
	
minBinNo, maxBinNo = 0, 255
 
#计算从左起第一个不为0的直方图柱的位置
for binNo, binValue in enumerate(hist):
    if binValue != 0:
		minBinNo = binNo
		break
#计算从右起第一个不为0的直方图柱的位置
for binNo, binValue in enumerate(reversed(hist)):
    if binValue != 0:
		maxBinNo = 255-binNo
		break
print minBinNo, maxBinNo
 
#生成查找表，方法来自参考文献1第四章第2节
for i,v in enumerate(lut):
	print i
	if i < minBinNo:
		lut[i] = 0
	elif i > maxBinNo:
		lut[i] = 255
	else:
		lut[i] = int(255.0*(i-minBinNo)/(maxBinNo-minBinNo)+0.5)
 
#计算
result = cv2.LUT(image, lut)  # 参数1：输入图像，参数2：查找表
cv2.imshow("Result", result)
cv2.imwrite("LutImage.jpg", result)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
### 直方图均衡化
有时图像的视觉上的缺陷并不在强度值集中在很窄的范围内。而是某些强度值的使用频率很大。比如第一幅图中，灰度图中间值的占了很大的比例。
在完美均衡的直方图中，每个柱的值都应该相等。即50%的像素值应该小于128，25%的像素值应该小于64。总结出的经验可定义为：在标准的直方图中p%的像素拥有的强度值一定小于或等于255×p%。将该规律用于均衡直方图中：强度i的灰度值应该在对应的像素强度值低于i的百分比的强度中。因此，所需的查询表可以由下面的式子建立：
```python
lut[i] = int(255.0 *p[i]) #p[i]是是强度值小于或等于i的像素的数目。
```
p[i]即直方图累积值，这是包含小于给点强度值的像素的直方图，以代替包含指定强度值像素的数目。
完美均衡的直方图，其累积直方图应为一条斜线。
通常来说，直方图均衡化大大增加了图像的表象。但根据图像可视内容的不同，不同图像的直方图均衡化产生的效果不尽相同
- openCV实现
```python
img = cv2.imread('图像路径',0)
equ = cv2.equalizeHist(img)
cv2.imshow('equ',equ)
```
- Numpy实现
```python
#coding=utf-8
import cv2
import numpy as np
 
image = cv2.imread("D:/test/unequ.jpg", 0)
 
lut = np.zeros(256, dtype = image.dtype )#创建空的查找表
 
hist,bins = np.histogram(image.flatten(),256,[0,256]) 
cdf = hist.cumsum() #计算累积直方图
cdf_m = np.ma.masked_equal(cdf,0) #除去直方图中的0值
cdf_m = (cdf_m - cdf_m.min())*255/(cdf_m.max()-cdf_m.min())#等同于前面介绍的lut[i] = int(255.0 *p[i])公式
cdf = np.ma.filled(cdf_m,0).astype('uint8') #将掩模处理掉的元素补为0
 
#计算
result2 = cdf[image]
result = cv2.LUT(image, cdf)
 
cv2.imshow("OpenCVLUT", result)
cv2.imshow("NumPyLUT", result2)
cv2.waitKey(0)
cv2.destroyAllWindows()
```