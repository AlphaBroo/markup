# 图像矫正

## 透视变换

[参考](https://blog.csdn.net/qq_40855366/article/details/81177176)

用于手机拍证件或名片时拍歪或者有边框

注意：图中角点坐标需要自己设定

- 原理

通过锁定书的角点，并设定改变后的角点，来达到矫正图像的目的。坐标原点在图片左上角！

- python实现

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt
img = cv2.imread('E:\\card2.jpg')
rows, cols = img.shape[:2]
# 原图中书本的四个角点
pts1 = np.float32([[69, 163], [704, 62], [162, 675], [970, 411]])
# 变换后分别在左上、右上、左下、右下四个点
pts2 = np.float32([[0, 1000], [0, 0], [750, 1000], [750, 0]])
# 生成透视变换矩阵
M = cv2.getPerspectiveTransform(pts1, pts2)
# 进行透视变换
dst = cv2.warpPerspective(img, M, (750, 1000))
plt.subplot(121), plt.imshow(img[:, :, ::-1]), plt.title('input')
plt.subplot(122), plt.imshow(dst[:, :, ::-1]), plt.title('output')
# img[:, :, ::-1]是将BGR转化为RGB
plt.show()
```

## Hough变换

[参考](https://blog.csdn.net/feilong_csdn/article/details/81586322)

用于文本扫描图片倾斜纠正

- 原理

霍夫变换主要是利用图片所在的空间和霍夫空间之间的变换，将图片所在的直角坐标系中具有形状的曲线或直线映射到霍夫空间的一个点上形成峰值，从而将检测任意形状的问题转化成了计算峰值的问题。即在图片所在的直角坐标系的一个直线，转换到霍夫空间便成了一点，并且是由多条直线相交而成，我们统计的峰值也就是该相交点的橡胶线的条数

这么难以理解，下面将用霍夫直线检测具体解释一下为什么可以将检测任意形状问题转化成计算峰值问题
对图片建立直角坐标系，则图片中如果存在一条直线，设为：`y = k*x + b`，此空间x、y 为未知数，k、b是参数； 而霍夫空间便是将k、b看成未知数，x、y看成参数，因此霍夫空间便是 `b = -x*k + y`

如果图片中有一条长的直线：`y = k*x + b`，那么肯定由很多个像素点`(x0， y0)`构成，但k、b是固定的，将这条直线上的像素点全部映射到霍夫空间中，`(k， b)`是一个固定的点，但`(x0, y0)`不同，所以在霍夫空间中便形成了多条直线汇聚于一点。

因此得出结论： 我们便是在霍夫空间中统计多个`(k、b)`，对每一个`(k， b)`上的直线条数进行统计，计算出峰值最高的那个，也就是在图片所在直角坐标系中我们要检测的直线。此时在回看最初那句话应该更理解了。

- python实现

```python
#先通过hough transform检测图片中的图片，计算直线的倾斜角度并实现对图片的旋转
import os
import cv2
import math
import random
import numpy as np
from scipy import misc, ndimage

filepath = 'E:/peking_rw/hough transform/tilt image correction/test image'
for filename in os.listdir(filepath):
	img = cv2.imread('E:/peking_rw/hough transform/tilt image correction/test image/%s'%filename)
	gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
	edges = cv2.Canny(gray,50,150,apertureSize = 3)
	
	#霍夫变换
	lines = cv2.HoughLines(edges,1,np.pi/180,0)
	for rho,theta in lines[0]:
	    a = np.cos(theta)
	    b = np.sin(theta)
	    x0 = a*rho
	    y0 = b*rho
	    x1 = int(x0 + 1000*(-b))
	    y1 = int(y0 + 1000*(a))
	    x2 = int(x0 - 1000*(-b))
	    y2 = int(y0 - 1000*(a))
	if x1 == x2 or y1 == y2:
		continue
	t = float(y2-y1)/(x2-x1)
	rotate_angle = math.degrees(math.atan(t))
	if rotate_angle > 45:
		rotate_angle = -90 + rotate_angle
	elif rotate_angle < -45:
		rotate_angle = 90 + rotate_angle
	rotate_img = ndimage.rotate(img, rotate_angle)
	misc.imsave('E:/peking_rw/hough transform/tilt image correction/test result/%s'%filename, rotate_img)
```

## Radon变换

## 傅里叶变换

由于拍照时，图像被旋转，为方便观看或使用，需要对旋转图像进行校正。

- 原理

2维图像的傅立叶变换可以用以下数学公式表达:
$$
F(k,l)=\displaystyle\sum\limits_{i=0}^{N-1}\sum\limits_{j=0}^{N-1} f(i,j)e^{-i2\pi(\frac{ki}{N}+\frac{lj}{N})}
$$

$$
e^{ix} = \cos{x} + i\sin {x}
$$

式中 `f` 是空间域(spatial domain)值， F 则是频域(frequency domain)值。

转换之后的频域值是复数， 因此，显示傅立叶变换之后的结果需要使用实数图像(real image) 加虚数图像(complex image), 或者幅度图像(magitude image)加相位图像(phase image)。 在实际的图像处理过程中，仅仅使用了幅度图像，因为幅度图像包含了原图像的几乎所有我们需要的几何信息。然而，如果你想通过修改幅度图像或者相位图像的方法来间接修改原空间图像，你需要使用逆傅立叶变换得到修改后的空间图像，这样你就必须同时保留幅度图像和相位图像了。

在此示例中，我将展示如何计算以及显示傅立叶变换后的幅度图像。由于数字图像的离散性，像素值的取值范围也是有限的。比如在一张灰度图像中，像素灰度值一般在0到255之间。 因此，我们这里讨论的也仅仅是离散傅立叶变换(DFT)。 如果你需要得到图像中的几何结构信息，那你就要用到它了。

在频域里面，对于一幅图像，高频部分代表了图像的细节、纹理信息；低频部分代表了图像的轮廓信息。如果对一幅精细的图像使用低通滤波器，那么滤波后的结果就剩下了轮廓了。这与信号处理的基本思想是相通的。如果图像受到的噪声恰好位于某个特定的“频率”范围内，则可以通过滤波器来恢复原来的图像。傅里叶变换在图像处理中可以做到：图像增强与图像去噪，图像分割之边缘检测，图像特征提取，图像压缩等等。

作者：SongpingWang 
来源：CSDN 
原文：https://blog.csdn.net/wsp_1138886114/article/details/83374333 
版权声明：本文为博主原创文章，转载请附上博文链接！

