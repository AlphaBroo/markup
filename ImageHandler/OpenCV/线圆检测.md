# 霍夫直线检测

```python
import cv2 as cv
import numpy as np


def line_detection(image):
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)  # 灰度化
    edges = cv.Canny(gray, 50, 150, apertureSize=3)  # 边缘检测
    lines = cv.HoughLines(edges, 1, np.pi/180, 200)  # 霍夫直线，输出极坐标参数
    for line in lines:
        print(type(lines))
        rho, theta = line[0]
        a = np.cos(theta)
        b = np.sin(theta)
        x0 = a * rho
        y0 = b * rho
        x1 = int(x0+1000*(-b))
        y1 = int(y0+1000*(a))
        x2 = int(x0-1000*(-b))
        y2 = int(y0-1000*(a))
        cv.line(image, (x1, y1), (x2, y2), (0, 0, 255), 2)  # 手动绘制直线
    cv.imshow("image-lines", image)


def line_detect_possible_demo(image):
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    edges = cv.Canny(gray, 50, 150, apertureSize=3)
    lines = cv.HoughLinesP(edges, 1, np.pi/180, 100, minLineLength=50, maxLineGap=10)  # 霍夫直线，输出线段坐标
    for line in lines:
        print(type(line))
        x1, y1, x2, y2 = line[0]
        cv.line(image, (x1, y1), (x2, y2), (0, 0, 255), 2)
    cv.imshow("line_detect_possible_demo", image)


print("--------- Python OpenCV Tutorial ---------")
src = cv.imread("D:/vcprojects/images/sudoku.png")
cv.namedWindow("input image", cv.WINDOW_AUTOSIZE)
cv.imshow("input image", src)
line_detect_possible_demo(src)
cv.waitKey(0)

cv.destroyAllWindows()

```

# 霍夫圆检测

```c++
void HoughCircles(InputArray image,OutputArray circles, int method, double dp, double minDist, double param1=100,double param2=100, int minRadius=0, int maxRadius=0 )
  
# 参数
第一个参数：InputArray类型的image，输入图像，即源图像，需为8位的灰度单通道图像。 
第二个参数：InputArray类型的circles，经过调用HoughCircles函数后此参数存储了检测到的圆的输出矢量，每个矢量由包含了3个元素的浮点矢量(x, y, radius)表示。 
第三个参数：int类型的method，即使用的检测方法，目前OpenCV中就霍夫梯度法一种可以使用，它的标识符为CV_HOUGH_GRADIENT，在此参数处填这个标识符即可。 
第四个参数：double类型的dp，用来检测圆心的累加器图像的分辨率于输入图像之比的倒数，且此参数允许创建一个比输入图像分辨率低的累加器。上述文字不好理解的话，来看例子吧。例如，如果dp= 1时，累加器和输入图像具有相同的分辨率。如果dp=2，累加器便有输入图像一半那么大的宽度和高度。 
第五个参数：double类型的minDist，为霍夫变换检测到的圆的圆心之间的最小距离，即让我们的算法能明显区分的两个不同圆之间的最小距离。这个参数如果太小的话，多个相邻的圆可能被错误地检测成了一个重合的圆。反之，这个参数设置太大的话，某些圆就不能被检测出来了。 
第六个参数：double类型的param1，有默认值100。它是第三个参数method设置的检测方法的对应的参数。对当前唯一的方法霍夫梯度法CV_HOUGH_GRADIENT，它表示传递给canny边缘检测算子的高阈值，而低阈值为高阈值的一半。 
第七个参数：double类型的param2，也有默认值100。它是第三个参数method设置的检测方法的对应的参数。对当前唯一的方法霍夫梯度法CV_HOUGH_GRADIENT，它表示在检测阶段圆心的累加器阈值。它越小的话，就可以检测到更多根本不存在的圆，而它越大的话，能通过检测的圆就更加接近完美的圆形了。 
第八个参数：int类型的minRadius,有默认值0，表示圆半径的最小值。 
第九个参数：int类型的maxRadius,也有默认值0，表示圆半径的最大值。需要注意的是，使用此函数可以很容易地检测出圆的圆心，但是它可能找不到合适的圆半径 
```

注意

```
因为霍夫圆检测对噪声比较敏感，所以首先要对图像做中值滤波。

基于效率考虑，Opencv中实现的霍夫变换圆检测是基于图像梯度的实现，分为两步:
1. 检测边缘，发现可能的圆心
2. 基于第一步的基础上从候选圆心开始计算最佳半径大小
```

示例

```python
import cv2 as cv
import numpy as np


def detect_circles_demo(image):
    dst = cv.pyrMeanShiftFiltering(image, 10, 100)  # 中值滤波
    cimage = cv.cvtColor(dst, cv.COLOR_BGR2GRAY)  # 灰度
    circles = cv.HoughCircles(cimage, cv.HOUGH_GRADIENT, 1, 20, param1=50, param2=30, minRadius=0, maxRadius=0)  # 霍夫圆检测
    circles = np.uint16(np.around(circles))  # 数值转换为整数
    for i in circles[0, :]:  
        cv.circle(image, (i[0], i[1]), i[2], (0, 0, 255), 2)  # 绘制圆
        cv.circle(image, (i[0], i[1]), 2, (255, 0, 0), 2)  # 绘制圆心
    cv.imshow("circles", image)


print("--------- Python OpenCV Tutorial ---------")
src = cv.imread("D:/vcprojects/images/coins_001.jpg")
cv.namedWindow("input image", cv.WINDOW_AUTOSIZE)
cv.imshow("input image", src)
detect_circles_demo(src)
cv.waitKey(0)

cv.destroyAllWindows()

```



