# 二值化

## 普通图像

- 全局二值化

```python
def threshold_demo(image):
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    ret, binary = cv.threshold(gray, 127, 255, cv.THRESH_BINARY|cv.THRESH_OTSU)  # 全局图像二值化
    print("threshold value %s"%ret)
    cv.imshow("binary", binary
```

- 自适应局部

```python
def local_threshold(image):
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    binary = cv.adaptiveThreshold(gray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 25, 10)  # 局部图像二值化，自适应
    cv.imshow("binary", binary)
```

- 自定义局部

```python
def custom_threshold(image):
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    h, w = gray.shape[:2]
    m = np.reshape(gray, [1, w*h])
    mean = m.sum() / (w*h)
    print("mean : ", mean)
    ret, binary = cv.threshold(gray, mean, 255, cv.THRESH_BINARY)  # 自定义均值，局部图形二值化
    cv.imshow("binary", binary)
```

## 超大图像

```python
import cv2 as cv
import numpy as np


def big_image_binary(image):
    print(image.shape)
    cw = 256
    ch = 256
    h, w = image.shape[:2]
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    for row in range(0, h, ch):
        for col in range(0, w, cw):
            roi = gray[row:row+ch, col:cw+col]
            print(np.std(roi), np.mean(roi))
            dev = np.std(roi)
            # 方法一：空白图像过滤
            # if dev < 15: 
            #     gray[row:row + ch, col:cw + col] = 255
            # else:
            #     ret, dst = cv.threshold(roi, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU)
            # 方法二：局部二值化
            dst = cv.adaptiveThreshold(roi, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 127, 20)  
            gray[row:row + ch, col:cw + col] = dst
    cv.imwrite("D:/vcprojects/result_binary.png", gray)


print("--------- Python OpenCV Tutorial ---------")
src = cv.imread("D:/vcprojects/images/red_text2.png")
#cv.namedWindow("input image", cv.WINDOW_AUTOSIZE)
#cv.imshow("input image", src)
big_image_binary(src)
cv.waitKey(0)

cv.destroyAllWindows()
```



# 泛洪填充

填充一个对象内部区域

```python
cv.floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal)

cv.floodFIll(image, mask, seedpoint, newVal, rect, loDiff, upDiff, flags)

# 参数
FLOODFILL_FLXED_RANGE	 # 改变图像，泛洪填充
FLOODFILL_MASK_ONLY   # 不改变图像、只填充遮罩层本身、忽略新的颜色值参数
```

填充二值图

```python
image = np.zeros([400, 400, 3], np.uint8)
image[100:300, 100:300, : ] = 255
cv.imshow("fill_binary", image)

mask = np.ones([402, 402, 1], np.uint8)
mask[101:301, 101:301] = 0
cv.floodFill(image, mask, (200, 200), (100, 2, 255), cv.FLOODFILL_MASK_ONLY)
cv.imshow("filled binary", image
```

填充彩色图

```python
copyImg = image.copy()
h, w = image.shape[:2]
mask = np.zeros([h+2, w+2], np.uint8)
cv.floodFill(copyImg, mask, (30, 30), (0, 255, 255), (100, 100, 100), (50, 50, 50), cv.FLOODFILL_FIXED_RANGE)  
cv.imshow("fill_color_demo", copyImg
```

# ROI

# 模糊操作

- 原理

```
1. 基于离散卷积
2. 定义好每个卷积核
3. 不同卷积核得到不同的卷积效果 4. 模糊是卷积的一种表象
```

- 均值模糊

用途

```
去除随机噪声
```

方法

```python
cv.blur(image, (3, 3))
```

- 中值模糊

用途

```
去除椒盐噪声
```

方法

```python
cv.medianBlur(image, 5)
```

- 自定义模糊

用途

```
自定义模糊效果
```

方法

```python
# 自定义卷积内核
# kernel = np.ones([5, 5], np.float32)/25  # 自定义卷积核，实现了椒盐去燥
kernel = np.array([[0, -1, 0],[-1, 5, -1],[0, -1, 0]], np.float32)  # 自定义卷积核，此内核实现了锐化
dst = cv.filter2D(image, -1, kernel=kernel)
cv.imshow("custom_blur_demo", dst)
```

- 高斯模糊

```python
# 产生高斯噪声
def clamp(pv):
    if pv > 255:
        return 255
    if pv < 0:
        return 0
    else:
        return pv

def gaussian_noise(image):
    """高斯噪声"""
    h, w, c = image.shape
    for row in range(h):
        for col in range(w):
            s = np.random.normal(0, 20, 3)
            b = image[row, col, 0]  # blue
            g = image[row, col, 1]  # green
            r = image[row, col, 2]  # red
            image[row, col, 0] = clamp(b + s[0])
            image[row, col, 1] = clamp(g + s[1])
            image[row, col, 2] = clamp(r + s[2])
    cv.imshow("noise image", image
              
# 高斯模糊，可抑制高斯噪声
dst = cv.GaussianBlur(src, (0, 0), 15)
```

# 边缘保留滤波

- 高斯双边

```python
dst = cv.bilateralFilter(image, 0, 100, 15)  # 边缘保留滤波：高斯双边,b预留为0，通过设定sigmacolor(大，便于区分),sigmaSpace(小，便于计算)来计算
```

- 均值迁移

```python
dst = cv.pyrMeanShiftFiltering(image, 10, 50)  # 边缘保留滤波：均值迁移
```

# 边缘提取

```
cv.canny(gray, T1, T2)
```

算法步骤

```
1. 高斯模糊
2. 灰度转换
3. 计算梯度
4. 非最大信号抑制
5. 高低阈值输出二值图像
```

参数注意

```
T1，T2为阈值，凡是高于T2的都保留，凡是小于T1都丢弃，从高于T2的像素出发，凡是大于T1而且相互连接的，都保留。最终得到一个输出二值图像。

推荐的高低阈值比值为 T2: T1 = 3:1/2:1其中T2 为高阈值，T1为低阈值
```

示例

```python
import cv2 as cv
import numpy as np


def edge_demo(image):
    blurred = cv.GaussianBlur(image, (3, 3), 0)  # 高斯模糊，降噪
    gray = cv.cvtColor(blurred, cv.COLOR_BGR2GRAY)  # 灰度化
    # X Gradient
    xgrad = cv.Sobel(gray, cv.CV_16SC1, 1, 0)  # canny要求不能是浮点数
    # Y Gradient
    ygrad = cv.Sobel(gray, cv.CV_16SC1, 0, 1)
    #edge
    #edge_output = cv.Canny(xgrad, ygrad, 50, 150)  # 经过梯度边缘提取
    edge_output = cv.Canny(gray, 50, 150)  # 模糊之后边缘提取
    cv.imshow("Canny Edge", edge_output)  # 黑白

    dst = cv.bitwise_and(image, image, mask=edge_output)  # 彩色
    cv.imshow("Color Edge", dst)


print("--------- Python OpenCV Tutorial ---------")
src = cv.imread("D:/vcprojects/images/topstar.png")
cv.namedWindow("input image", cv.WINDOW_AUTOSIZE)
cv.imshow("input image", src)
edge_demo(src)
cv.waitKey(0)

cv.destroyAllWindows()

```

# 轮廓发现

```python
import cv2 as cv
import numpy as np


def edge_demo(image):
    blurred = cv.GaussianBlur(image, (3, 3), 0)  # 高斯模糊
    gray = cv.cvtColor(blurred, cv.COLOR_BGR2GRAY)  # 灰度化
    # X Gradient
    xgrad = cv.Sobel(gray, cv.CV_16SC1, 1, 0)  # 梯度
    # Y Gradient
    ygrad = cv.Sobel(gray, cv.CV_16SC1, 0, 1)  # 梯度
    #edge
    #edge_output = cv.Canny(xgrad, ygrad, 50, 150)
    edge_output = cv.Canny(gray, 30, 100)  # 边缘检测
    cv.imshow("Canny Edge", edge_output)
    return edge_output


def contours_demo(image):
    """
    dst = cv.GaussianBlur(image, (3, 3), 0)  # 高斯模糊
    gray = cv.cvtColor(dst, cv.COLOR_BGR2GRAY)  # 灰度
    ret, binary = cv.threshold(gray, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU)  # 自动二值化
    cv.imshow("binary image", binary)
    """
    binary = edge_demo(image)

    # cloneImage, contours, heriachy = cv.findContours(binary, cv.RETR_Tree, cv.CHAIN_APPROX_SIMPLE)  # 所有圆轮廓
    cloneImage, contours, heriachy = cv.findContours(binary, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)  # 外围圆轮廓
    for i, contour in enumerate(contours):
        cv.drawContours(image, contours, i, (0, 0, 255), 2)  # 2，绘制轮廓，-1，填充
        approxCurve = cv.approxPolyDP(contour, 4, True)
        if approxCurve.shape[0] > 6:
            cv.drawContours(image, contours, i, (0, 255, 255), 2)
        if approxCurve.shape[0] == 4:
            cv.drawContours(image, contours, i, (255, 255, 0), 2)
        print(approxCurve.shape[0])
        print(i)
    cv.imshow("detect contours", image)


print("--------- Python OpenCV Tutorial ---------")
src = cv.imread("D:/vcprojects/images/blob.png")
cv.namedWindow("input image", cv.WINDOW_AUTOSIZE)
cv.imshow("input image", src)
contours_demo(src)
cv.waitKey(0)

cv.destroyAllWindows()

```

