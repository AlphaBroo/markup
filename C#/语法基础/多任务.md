# 多任务

## 多线程

**线程** 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果您的应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。

线程是**轻量级进程**。一个使用线程的常见实例是现代操作系统中并行编程的实现。使用线程节省了 CPU 周期的浪费，同时提高了应用程序的效率。

### Thread

`System.Threading`命名空间下的`Thread`类，用于对线程进行管理，如创建、暂停、终止、合并线程、设置其优先级并获取其状态。同时，`System.Threading.ThreadPool`和`System.ComponentModel.BackgroundWorker`也可以实现线程处理。

- 属性

| 属性               | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| CurrentContext     | 获取线程正在其中执行的当前上下文。                           |
| CurrentCulture     | 获取或设置当前线程的区域性。                                 |
| CurrentPrinciple   | 获取或设置线程的当前负责人（对基于角色的安全性而言）。       |
| CurrentThread      | 获取当前正在运行的线程。                                     |
| CurrentUICulture   | 获取或设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源。 |
| ExecutionContext   | 获取一个 ExecutionContext 对象，该对象包含有关当前线程的各种上下文的信息。 |
| IsAlive            | 获取一个值，该值指示当前线程的执行状态。                     |
| IsBackground       | 获取或设置一个值，该值指示某个线程是否为后台线程。           |
| IsThreadPoolThread | 获取一个值，该值指示线程是否属于托管线程池。                 |
| ManagedThreadId    | 获取当前托管线程的唯一标识符。                               |
| Name               | 获取或设置线程的名称。                                       |
| Priority           | 获取或设置一个值，该值指示线程的调度优先级。(ThreadPriority的枚举值) |
| ThreadState        | 获取一个值，该值包含当前线程的状态。                         |

- 方法

| name                             | desc                                                         |
| :------------------------------- | :----------------------------------------------------------- |
| `Thread()`                       | 初始化Thread类的新实例，指定允许对象在线程启动时传递给线程的委托 |
| `Abort()`                        | 在调用此方法的线程上引发 ThreadAbortException，以开始终止此线程的过程。调用此方法通常会终止线程。 |
| `Interrupt()`                    | 中断处于 WaitSleepJoin 线程状态的线程                        |
| `join()`                         | 在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻塞调用线程，直到某个线程终止为止。此方法有不同的重载形式。 |
| `ResetAbort()`                   | 取消为当前线程请求的 Abort。                                 |
| `Resume()`                       | 继续挂起的线程                                               |
| `Sleep(int millisecondsTimeout)` | 将当前线程阻塞指定的毫秒数                                   |
| `Start()`                        | 开始一个线程                                                 |
| `Suspend()`                      | 挂起一个线程的运行                                           |

### 线程的操作

- 线程的生命周期

线程生命周期开始于 System.Threading.Thread 类的对象被创建时，结束于线程被终止或完成执行时。

下面列出了线程生命周期中的各种状态：

```
- 未启动状态：当线程实例被创建但Start方法未被调用时的状况。
- 就绪状态：当线程准备好运行并等待CPU周期时的状况。
- 不可运行状态
	- 已经调用Sleep方法
  - 已经调用Wait方法
  - 通过I/O操作阻塞
- 死亡状态：当线程已完成执行或已中止时的状况。
```

当实例化一个Thread对象时，就创建了一个新线程。新创建的线程最初处于Unstarted状态中。通过调用Start方法，可以将Unstarted线程转换为Running状态。通过调用Abort方法，可以将Running线程转换为AbortRequested状态。当AbortRequested线程捕获到System.Threading.ThreadAbortException异常后，可以调用ResetAbort方法。通过调用Thread.Sleep或者Thread.Join方法，可以将Running线程转换为WaitSleepJoin状态，线程被阻塞。

- 主线程

在 C# 中，**System.Threading.Thread** 类用于线程的工作。它允许创建并访问多线程应用程序中的单个线程。进程中第一个被执行的线程称为**主线程**。

当 C# 程序开始执行时，主线程自动创建。使用 **Thread** 类创建的线程被主线程的子线程调用。您可以使用 Thread 类的 **CurrentThread** 属性访问线程。

```c#
using System;
using System.Threading;

namespace MultithreadingApplication
{
    class MainThreadProgram
    {
        static void Main(string[] args)
        {
            Thread th = Thread.CurrentThread;
            th.Name = "MainThread";
            Console.WriteLine("This is {0}", th.Name);
            Console.ReadKey();
        }
    }
}
```

#### 创建

不传参的情况下，可以使用`ThreadStart`代理来链接执行函数。如果希望传递参数给执行函数，可使用`ParameterizedThreadStart`代理来链接执行函数

构造函数

```c#
Thread(ThreadStart); // 初始化Thread类的新实例
Thread(ParameterizedThreadStart); // 初始化Thread类的新实例，指定允许对象在线程启动时传递给线程的委托
Thread(ParameterizedThreadStart, Int32); // 初始化Thread类的新实例，指定允许对象在线程启动时传递给线程的委托，并制定线程的最大堆栈大小
Thread(ThreadStart, Int32); // 初始化Thread类的新实例，指定线程的最大堆栈大小
```

创建和使用不带参数的线程

```c#
namespace para
{
		class Program
		{
				static void Main(string[] args)
				{
						Thread ThreadSample = new Thread(new ThreadStart(MethodA));
						ThreadSample.Start();
				}
      	
      	private static void MethodA(){...}
		}
}
```

创建和使用带参数的线程

```c#
namespace para
{
		class Program
		{
				static void Main(string[] args)
				{
						Thread ThreadSample = new Thread(new ParameterizedThreadStart(MethodA));
						ThreadSample.Start('params');
				}
      	
      	private static void MethodA(object obj)
        {
           Console.WriteLine(obj.ToSting());
        }
		}
}
```

创建和使用带多个参数的线程

```c#
// 由于Thred只提供了两种构造函数，若传递多个参数，可以将参数作为类的属性。
class Program
{
			static void Main(string[] args)
			{
						ThreadDemo ClassOne = new ThreadDemo();
						ClassOne.para1 = 2;
        		ClassOne.para2 = 3;
        		Thread ThreadOne = new Thread(new ThreadStart(ClassOne.MethodDemo));
        		ThreadOne.Start();
        		Console.Read();
			}	
}
class ThreadDemo
{
     public int para1, para2;
     public void MethodDemo()
     {
       Console.WriteLine("para1={0},para2={1}", this.para1, this.para2);
      }
}

// 使用结构体
public struct StructRow
{
  	// 定义公共的整型变量
  	public int para1;
  	public int para2;
}

class Program
{
			static void Main(string[] args)
			{
						ThreadDemo ClassOne = new ThreadDemo();
						// 创建结构
        		StructRow rcM;
        		rcM.para1 = 2;
        		rcM.para2 = 3;
        		Thread ThreadOne = new Thread(new ParameterizedThreadStart(ThreadDemo.MethodDemo));
        		ThreadOne.Start(rcM);
        		Console.Read();
			}
}
class ThreadDemo
{ 
     public void MethodDemo(object rcMin)
     {
       // 接收传入参数
  	 	 StructRow rowCol = (StructRow)rcMin;
       Console.WriteLine("para1={0},para2={1}", rowCol.para1, rowCol.para2);
      }
}
```

#### 启动

```c#
// 启动线程
线程名.Start();
// 设置优先级
线程名.priority = ThreadPriority.Highest(Lowest/...);
// 休眠
Thread.Sleep(1000);
// 挂起
线程名.Suspend();
// 继续
if(线程名.ThreadState == ThreadState.Suspended)
{ 线程名.Resume }
```

#### 结束

```c#
Abort();
Sleep(int);
Suspend();
Resume();
```

### 线程池

### 线程同步



