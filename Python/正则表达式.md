# 正则表达式

正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。

## 匹配单个字符

| 字符 | 功能                             |
| ---- | -------------------------------- |
| .    | 匹配任意1个字符（除了\n）        |
| [ ]  | 匹配[ ]中列举的字符              |
| \d   | 匹配数字，即0-9                  |
| \D   | 匹配非数字，即不是数字           |
| \s   | 匹配空白，即 空格，tab键         |
| \S   | 匹配非空白                       |
| \w   | 匹配单词字符，即a-z、A-Z、0-9、_ |
| \W   | 匹配非单词字符                   |

## 匹配多个字符

| 字符  | 功能                                                |
| ----- | --------------------------------------------------- |
| *     | 匹配前一个字符出现0次或者无限次，即可有可无         |
| +     | 匹配前一个字符出现1次或者无限次，即至少有1次        |
| ?     | 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 |
| {m}   | 匹配前一个字符出现m次                               |
| {m,n} | 匹配前一个字符出现从m到n次                          |

## 匹配开头结尾

| 字符 | 功能           |
| ---- | -------------- |
| ^    | 匹配字符串开头 |
| $    | 匹配字符串结尾 |

## 匹配分组

| 字符         | 功能                             |
| ------------ | -------------------------------- |
| \|           | 匹配左右任意一个表达式           |
| (ab)         | 将括号中字符作为一个分组         |
| `\num`       | 引用分组num匹配到的字符串        |
| `(?P<name>)` | 分组起别名                       |
| (?P=name)    | 引用别名为name分组匹配到的字符串 |

#python中使用

```
Python提供re模块，包含所有正则表达式的功能。由于Python的字符串本身也用\转义，所以要使用r前缀，就不用考虑转义的问题了
```

##匹配

**match**

```
# match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None

>>> import re
>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
>>>
```

**search**

```
>>>import re
>>>ret = re.search(r"\d+", "阅读次数为 9999")
>>>ret.group()
'9999'
```

**findall**

```
>>>import re
>>>ret = re.findall(r"\d+", "python = 9999, c = 7890, c++ = 12345")
>>>print(ret)
['9999', '7890', '12345']
```

## 替换

```
>>>import re
>>>ret = re.sub(r"\d+", '998', "python = 997")
>>>print(ret)
python = 998
```

##分割

```
# 正常切分代码
>>> 'a b   c'.split(' ')
['a', 'b', '', '', 'c']

# 使用正则表达式
>>> re.split(r'\s+', 'a b   c')
['a', 'b', 'c']
>>> re.split(r'[\s\,]+', 'a,b, c  d')
['a', 'b', 'c', 'd']
>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
```

## 分组

```
# 正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）,

# group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。

>>> m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
>>> m
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'
```

## 贪婪匹配

正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的`0`

```
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')
```

在"*","?","+","{m,n}"后面加上？，使贪婪变成非贪婪。

```
>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')
```

## 编译

当我们在Python中使用正则表达式时，re模块内部会干两件事情：

- 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
- 用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：

```
>>> import re
# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')
```



