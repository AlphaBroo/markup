# 写入数据库迁移

这一节介绍你可能遇到的在不同情况下如何分析和编写数据库迁移. 有关迁移的入门资料，请查看 [主题指南](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/topics/migrations.html).

## 数据迁移和多个数据库

在使用多个数据库时，需要解决是否针对某个特定数据库运行迁移。 比如说你 **只是** 想在特定的数据库上做迁移。

为此你可以在`schema_editor.connection.alias`中通过查看`RunPython` 属性来检查数据库连接别名：

```python
from django.db import migrations

def forwards(apps, schema_editor):
    if schema_editor.connection.alias != 'default':
        return
    # Your migration code goes here

class Migration(migrations.Migration):

    dependencies = [
        # Dependencies to other migrations
    ]

    operations = [
        migrations.RunPython(forwards),
    ]
```

你也可以提供一个提示作为 `**hints`参数传递到数据库路由的[`allow_migrate()`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/topics/db/multi-db.html#allow_migrate) 方法：

```python
# myapp/dbrouters.py
class MyRouter(object):

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        if 'target_db' in hints:
            return db == hints['target_db']
        return True
```

然后，要在你的迁移中利用，执行以下操作：

```python
from django.db import migrations

def forwards(apps, schema_editor):
    # Your migration code goes here
    ...

class Migration(migrations.Migration):

    dependencies = [
        # Dependencies to other migrations
    ]

    operations = [
        migrations.RunPython(forwards, hints={'target_db': 'default'}),
    ]
```

如果你的`model_name`或者`RunSQL`操作只对一个模型有影响，最佳实践是将`RunPython`作为提示传递，使其尽可能对路由可见。 这对可复用的和第三方应用极其重要。

## 添加唯一字段的迁移

如果你应用了一个“朴素”的迁移，向表中一个已存在的行中添加了一个唯一的非空字段，会产生错误，因为位于已存在行中的值只会生成一次。所以需要移除唯一性的约束。

所以，应该执行下面的步骤。 在这个例子中，我们会以默认值添加一个非空的[`UUIDField`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/fields.html#django.db.models.UUIDField)字段。 你可以根据你的需要修改各个字段。

- 使用`default=uuid.uuid4`和`unique=True`参数添加模型中的字段（为添加的字段类型选择适当的默认值）。

- 运行 [`makemigrations`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/django-admin.html#django-admin-makemigrations) 命令。 这应该使用`AddField`操作生成迁移。

- 通过运行`makemigrations myapp - empty`，为同一个应用程序生成两个空的迁移文件。 我们已经重命名迁移文件，以便在下面的示例中给出有意义的名称。

- 将`AddField`操作从自动生成的迁移（三个新文件中的第一个）复制到最后一次迁移，将`AddField`更改为`AlterField`，并添加导入`uuid`和`models`。 像这样：

  ```python
# 0006_remove_uuid_null.py
  # Generated by Django A.B on YYYY-MM-DD HH:MM
  from django.db import migrations, models
  import uuid
  
  class Migration(migrations.Migration):
  
      dependencies = [
          ('myapp', '0005_populate_uuid_values'),
      ]
  
      operations = [
          migrations.AlterField(
              model_name='mymodel',
              name='uuid',
              field=models.UUIDField(default=uuid.uuid4, unique=True),
          ),
      ]
  ```
  
- 编辑第一个迁移文件。 生成的迁移类看上去像这样：

  ```python
# 0004_add_uuid_field.py
  class Migration(migrations.Migration):
  
      dependencies = [
          ('myapp', '0003_auto_20150129_1705'),
      ]
  
      operations = [
          migrations.AddField(
              model_name='mymodel',
              name='uuid',
              field=models.UUIDField(default=uuid.uuid4, unique=True),
          ),
      ]
  ```
  
将`unique=True`更改为`null=True` - 这将创建中间空字段，并推迟创建唯一约束，直到我们在所有行上填充唯一值。
  
- 在第一个空迁移文件中，添加一个[`RunPython`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/migration-operations.html#django.db.migrations.operations.RunPython)或[`RunSQL`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/migration-operations.html#django.db.migrations.operations.RunSQL)操作，以生成每个现有行的唯一值（在示例中为UUID）。 还添加导入`uuid`。 像这样：

  ```python
# 0005_populate_uuid_values.py
  # Generated by Django A.B on YYYY-MM-DD HH:MM
  from django.db import migrations
  import uuid
  
  def gen_uuid(apps, schema_editor):
      MyModel = apps.get_model('myapp', 'MyModel')
      for row in MyModel.objects.all():
          row.uuid = uuid.uuid4()
          row.save(update_fields=['uuid'])
  
  class Migration(migrations.Migration):
  
      dependencies = [
          ('myapp', '0004_add_uuid_field'),
      ]
  
      operations = [
          # omit reverse_code=... if you don't want the migration to be reversible.
          migrations.RunPython(gen_uuid, reverse_code=migrations.RunPython.noop),
      ]
  ```
  
- 现在，您可以照常使用[`migrate`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/django-admin.html#django-admin-migrate)命令应用迁移。

  注意如果你在这个迁移运行时让对象被创建，就会产生竞争条件(race condition)。 在`uuid`之后， `RunPython`之前创建的对象会覆写他们原始的`AddField`。

### 非原子迁移

在支持DDL事务（SQLite和PostgreSQL）的数据库上，默认情况下迁移将在事务中运行。 对于在大型表上执行数据迁移的用例，您可能希望通过将`atomic`属性设置为`False`来防止迁移在事务中运行：

```python
from django.db import migrations

class Migration(migrations.Migration):
    atomic = False
```

在这样的迁移中，所有操作都在没有事务的情况下运行。 可以使用[`atomic()`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/topics/db/transactions.html#django.db.transaction.atomic)或通过将`atomic=True`传递给`RunPython`来执行事务内部迁移的部分。

以下是一个非原子数据迁移的示例，可以更小批量更新大型表：

```python
import uuid

from django.db import migrations, transaction

def gen_uuid(apps, schema_editor):
    MyModel = apps.get_model('myapp', 'MyModel')
    while MyModel.objects.filter(uuid__isnull=True).exists():
        with transaction.atomic():
            for row in MyModel.objects.filter(uuid__isnull=True)[:1000]:
                row.uuid = uuid.uuid4()
                row.save()

class Migration(migrations.Migration):
    atomic = False

    operations = [
        migrations.RunPython(gen_uuid),
    ]
```

`atomic`属性对不支持DDL事务的数据库（例如MySQL，Oracle）没有影响。

## 控制迁移顺序

Django确定迁移的顺序不是每个迁移的文件名，而是通过使用`Migration`类中的两个属性构建一个图：`dependencies`和`run_before`

如果您使用[`makemigrations`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/django-admin.html#django-admin-makemigrations)命令，您可能已经看到`dependencies`，因为自动创建的迁移将其定义为创建过程的一部分。

`dependencies`属性声明如下：

```python
from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ('myapp', '0123_the_previous_migration'),
    ]
```

通常这将是足够的，但是您可能需要确保您的迁移在其他迁移之前运行*。* 例如，在您的[`AUTH_USER_MODEL`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/settings.html#std:setting-AUTH_USER_MODEL)替换后，使第三方应用的迁移运行*非常有用。*

要实现这一点，请将您所需要的所有迁移置于`Migration`类的`run_before`属性中：

```python
class Migration(migrations.Migration):
    ...

    run_before = [
        ('third_party_app', '0001_do_awesome'),
    ]
```

如果可能，最好使用`dependencies`超过`run_before`。 如果在要编写的迁移中要运行的迁移中指定`dependencies`是不合需要或不切实际的，那么您应该只使用`run_before`。

## 在第三方应用程序之间迁移数据

您可以使用数据迁移将数据从一个第三方应用程序移动到另一个应用程序。

如果以后计划删除旧应用程序，则需要根据是否安装旧应用程序来设置`dependencies`属性。 否则，卸载旧应用程序后，您将丢失依赖关系。 同样，您需要在`apps.get_model()`调用中捕获来自旧应用程序的模型的[`LookupError`](https://docs.python.org/3/library/exceptions.html#LookupError)。 这种方法允许您将项目部署在任何地方，而无需先安装然后卸载旧应用程序。

以下是迁移示例：

```python
# myapp/migrations/0124_move_old_app_to_new_app.py
from django.apps import apps as global_apps
from django.db import migrations

def forwards(apps, schema_editor):
    try:
        OldModel = apps.get_model('old_app', 'OldModel')
    except LookupError:
        # The old app isn't installed.
        return

    NewModel = apps.get_model('new_app', 'NewModel')
    NewModel.objects.bulk_create(
        NewModel(new_attribute=old_object.old_attribute)
        for old_object in OldModel.objects.all()
    )

class Migration(migrations.Migration):
    operations = [
        migrations.RunPython(forwards, migrations.RunPython.noop),
    ]
    dependencies = [
        ('myapp', '0123_the_previous_migration'),
        ('new_app', '0001_initial'),
    ]

    if global_apps.is_installed('old_app'):
        dependencies.append(('old_app', '0001_initial'))
```

还要考虑当迁移未应用时想要发生什么。 您可以不做任何事情（如上面的示例）或从新应用程序中删除部分或全部数据。 相应地调整[`RunPython`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/migration-operations.html#django.db.migrations.operations.RunPython)操作的第二个参数。

## 将非托管模型更改为托管

如果要将非托管模型（[`managed=False`](https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/options.html#django.db.models.Options.managed)）更改为托管，则必须删除`managed=False`，并在对模型进行其他模式相关更改之前生成迁移，因为迁移中出现的模式更改包含要更改`Meta.managed`的操作可能不适用。
