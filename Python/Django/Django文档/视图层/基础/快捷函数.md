# 快捷函数

`django.shortcuts` 收集了“跨越” 多层MVC 的辅助函数和类。 换句话讲，这些函数/类为了方便，引入了可控的耦合。

| name                 | desc                                                         |
| -------------------- | ------------------------------------------------------------ |
| `render`             | 结合一个给定的模板和一个给定的上下文字典，并返回渲染后的 `HttpResponse ` |
| `render_to_response` | 根据一个给定的上下文字典渲染一个给定的目标，并返回渲染后的`HttpResponse` |
| `redirect`           | 为传递进来的参数返回`HttpResponseRedirect`给正确的URL        |
| `get_object_or_404`  | 在一个给定的模型管理器上调用`get()`，但是引发`Http404` 而不是模型的`DoesNotExist`异常 |
| `get_list_or_404`    | 返回一个给定模型管理器上`filter()`的结果，并将结果映射为一个列表，如果结果为空则返回`Http404` |

## render

```python
render(request, template_name, context=None, content_type=None, status=None, using=None)
# 结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse对象。
# render() 与以一个强制使用RequestContext的context_instance 参数调用render_to_response() 相同。
# Django 不提供返回TemplateResponse 的快捷函数，因为TemplateResponse 的构造与render() 提供的便利是一个层次的。
```

参数

| name            | option | desc                                                         |
| --------------- | ------ | ------------------------------------------------------------ |
| `request`       | 必选   | 用于成response                                               |
| `template_name` | 必选   | 要使用的模板的完整名称或者模板名称的一个序列                 |
| `context`       | 可选   | 要添加到模板上下文的值的字典。默认情况下，这是一个空字典。如果字典中的值是可调用的，则视图将在呈现模板之前调用它。 |
| `content_type`  | 可选   | 生成的文档要使用的MIME 类型。默认为`DEFAULT_CONTENT_TYPE`设置的值。 |
| `status`        | 可选   | 响应的状态码。默认为`200`                                    |
| `using`         | 可选   | 用于加载模板使用的模板引擎的`名称`                           |

示例

```python
# 渲染模板myapp/index.html，MIIME 类型为application/xhtml+xml
from django.shortcuts import render

def my_view(request):
    # View code here...
    return render(request, 'myapp/index.html', {"foo": "bar"},
        content_type="application/xhtml+xml")
  
# 非快捷等价形式
# 1.8
from django.http import HttpResponse
from django.template import RequestContext, loader

def my_view(request):
    # View code here...
    t = loader.get_template('myapp/index.html')
    c = RequestContext(request, {'foo': 'bar'})
    return HttpResponse(t.render(c),
        content_type="application/xhtml+xml")
# 2.0
from django.http import HttpResponse
from django.template import loader

def my_view(request):
    # View code here...
    t = loader.get_template('myapp/index.html')
    c = {'foo': 'bar'}
    return HttpResponse(t.render(c, request), content_type='application/xhtml+xml')
```

## render_to_response

```python
render_to_response(template_name, context=None, content_type=None, status=None, using=None)

# 根据一个给定的上下文字典渲染一个给定的目标，并返回渲染后的HttpResponse
# 参数含义类似render
# 2.0中不推荐使用
```

示例

```python
# 渲染模板myapp/index.html，MIIME 类型为application/xhtml+xml
from django.shortcuts import render_to_response

def my_view(request):
    # View code here...
    return render_to_response('myapp/index.html', {"foo": "bar"}, content_type="application/xhtml+xml")
  
# 非快捷等价形式
from django.http import HttpResponse
from django.template import Context, loader

def my_view(request):
    # View code here...
    t = loader.get_template('myapp/index.html')
    c = Context({'foo': 'bar'})
    return HttpResponse(t.render(c), content_type="application/xhtml+xml")
```

## redirect

```python
redirect(to, permanent=False, *args, **kwargs)

# 为传递进来的参数返回`HttpResponseRedirect`给正确的URL

# 参数可以是
一个模型：将调用模型的get_absolute_url() 函数
一个视图，可以带有参数：将使用urlresolvers.reverse 来反向解析名称
一个绝对的或相对的URL，将原封不动的作为重定向的位置。
# 默认返回一个临时的重定向；传递permanent=True 可以返回一个永久的重定向。
```

示例

```python
# 通过传递一个对象；将调用get_absolute_url()方法来获取重定向的URL
from django.shortcuts import redirect

def my_view(request):
    ...
    object = MyModel.objects.get(...)
    return redirect(object)  # 临时重定向
  	return redirect(object, permanent=True)  # 永久重定向
  
# 通过传递一个视图的名称，可以带有位置参数和关键字参数；将使用reverse()方法反向解析URL
return redirect('some-view-name', foo='bar')
 
# 传递要重定向的一个硬编码的URL
return redirect('/some/url/')
return redirect('http://example.com/')  # 完整URL
```

## get_object_or_404

```python
get_object_or_404(klass, *args, **kwargs)

# 在一个给定的模型管理器上调用get()，但是引发`Http404` 而不是模型的`DoesNotExist`异常
# 参数
klass  		# 获取该对象的一个Model类，Manager或QuerySet实例。
**kwargs	# 查询的参数，格式应该可以被get()和filter()接受
```

示例

```python
# 从MyModel中使用主键1来获取对象
from django.shortcuts import get_object_or_404

def my_view(request):
    my_object = get_object_or_404(MyModel, pk=1)
# 等价
from django.http import Http404

def my_view(request):
    try:
        my_object = MyModel.objects.get(pk=1)
    except MyModel.DoesNotExist:
        raise Http404("No MyModel matches the given query.")

# QuerySet
queryset = Book.objects.filter(title__startswith='M')
get_object_or_404(queryset, pk=1)
# 等价
get_object_or_404(Book, title__startswith='M', pk=1)

# Manager
get_object_or_404(Book.dahl_objects, title='Matilda')   # 自定义管理器尤其有用
author = Author.objects.get(name='Roald Dahl')					# 使用关联的管理器
get_object_or_404(author.book_set, title='Matilda')  
```

## get_list_or_404

```python
get_list_or_404(klass, *args, **kwargs)

# 返回一个给定模型管理器上filter()的结果，并将结果映射为一个列表，如果结果为空则返回`Http404`
# 参数
klass  		# 获取该对象的一个Model类，Manager或QuerySet实例。
**kwargs	# 查询的参数，格式应该可以被get()和filter()接受
```

示例

```python
# 从MyModel 中获取所有发布出来的对象
from django.shortcuts import get_list_or_404

def my_view(request):
    my_objects = get_list_or_404(MyModel, published=True)
# 等价
from django.http import Http404

def my_view(request):
    my_objects = list(MyModel.objects.filter(published=True))
    if not my_objects:
        raise Http404("No MyModel matches the given query.")
```