## 权限认证

[参考](https://www.cnblogs.com/wangwei916797941/p/7398934.html)

在Django的世界中，在权限管理中有内置的Authentication系统。用来管理帐户，组，和许可。还有基于cookie的用户session。
Django内置的权限系统包括以下三个部分：

```
1. 用户（Users）
2. 许可（Permissions）：用来定义一个用户（user）是否能够做某项任务（task）
3. 组（Groups）：一种可以批量分配许可到多个用户的通用方式
```

使用组件

```
1. 将'django.contrib.auth'和'django.contrib.contenttypes'放到settings.py中的INSTALLED_APPS中。（使用contenttypes的原因是auth中的Permission模型依赖于contenttypes）
2. 执行manage.py syncdb
3. 装好就可以使用了
```

执行manage.py shell来启动脚本，对其中的一些API进行学习和使用。

### User模型

User模型对应于一个用户，一个帐户，位于'django.contrib.auth.models'模块中。
User对象有两个多对多的属性分别是：groups和user_permissions：

```shell
>>>from django.contrib.auth.models import User
>>>es = User.objects.create_user('esperyong','esperyong@gmail.com','123456')
>>>es.groups
<django.db.models.fields.related.ManyRelatedManager at 0x10d0642d0>
>>>es.user_permissions
<django.db.models.fields.related.ManyRelatedManager at 0x10d014c50>
```

使用

```shell
# 直接将一个列表赋值给该属性：
es.groups = [group_list]
es.user_permissions = [permission_list]
# 使用add方法将对象加入：
es.groups.add(group, group, ...)
es.user_permissions.add(permission, permission, ...)
# 使用remove方法将对象删除：
es.groups.remove(group, group, ...)
es.user_permissions.remove(permission, permission, ...)
# 使用clear方法将所有对象删除：
es.groups.clear()
es.user_permissions.clear()
```

- API

User对象属性

| name         | type     | Desc                                                         |
| ------------ | -------- | ------------------------------------------------------------ |
| username     | String   | 必填。30个字符以内。                                         |
| first_name   | String   | 可选。30个字符以内。                                         |
| last_name    | String   | 可选。30个字符以内。                                         |
| email        |          | 可选                                                         |
| password     |          | 明文密码的hash或者是某种元数据。该属性不应该直接赋值明文密码，而应该通过set_password()方法进行赋值，在后面有详细说明TODO。 |
| is_staff     | Boolean  | 用这个来判断是否用户可以登录进入admin site。                 |
| is_active    | Boolean  | 用来判断该用户是否是可用激活状态。在删除一个帐户的时候，可以选择将这个属性置为False，而不是真正删除。这样如果应用有外键引用到这个用户，外键就不会被破坏。 |
| is_superuser | Boolean  | 该属性用来表示该用户拥有所有的许可，而无需明确的赋予给他。   |
| last_login   | datetime | 最近一次登陆时间                                             |
| date_joined  | datetime | 创建时间                                                     |

方法

除了DjangoModel对象的通用方法之外，User对象有以下特有方法

| name                                          | return        | desc                                                         |
| --------------------------------------------- | ------------- | ------------------------------------------------------------ |
| `is_anonymous()`                              | 永远返回False | 用来将User对象和AnonymousUser(未登录的匿名用户)对象作区分用的识别方法。通常，最好用is_authenticated()方法 |
| `is_authenticated()`                          | 永远返回True  | *该方法不代表该用户有任何的许可，也不代表该用户是active的，而只是表明该用户提供了正确的username和password。* |
| `get_full_name()`                             | 一个字符串    | 是first_name和last_name中间加一个空格组成                    |
| `set_password(raw_password)`                  |               | 调用该方法时候传入一个明文密码，该方法会进行hash转换。该方法调用之后并不会保存User对象。 |
| `check_password(raw_password)`                |               | 如果传入的明文密码是正确的返回True。该方法和set_password是一对，也会考虑hash转换。 |
| `set_unusable_password()`                     | Boolean       | 将用户设置为没有密码的状态。调用该方法后，check_password()方法将会永远返回false。但是如果，调用set_password()方法重新设置密码后，该方法将会失效，has_usable_password()也会返回True。 |
| `has_usable_password()`                       | Boolean       | 在调用set_unusable_password()方法之后，该方法返回False，正常情况下返回True。 |
| `get_group_permissions(obj=None)`             |               | 返回该用户通过组所拥有的许可（字符串列表每一个代表一个许可）。obj如果指定，将会返回关于该对象的许可，而不是模型。 |
| `get_all_permissions(obj=None)`               |               | 返回该用户所拥有的所有的许可，包括通过组的和通过用户赋予的许可。 |
| `has_perm(perm,obj=None)`                     |               | 如果用户有传入的perm，则返回True。perm可以是一个格式为：'<app label>.<permission codename>'的字符串。如果User对象为inactive，该方法永远返回False。和前面一样，如果传入obj，则判断该用户对于这个对象是否有这个许可。 |
| `has_perms(perm_list,obj=None)`               |               | 和has_perm一样，不同的地方是第一个参数是一个perm列表，只有用户拥有传入的每一个perm，返回值才是True。 |
| `has_module_perms(package_name)`              |               | 传入的是Django app label，按照'<app label>.<permission codename>'格式。当用户拥有该app label下面所有的perm时，返回值为True。如果用户为inactive，返回值永远为False。 |
| `email_user(subject,message,from_email=None)` |               | 发送一封邮件给这个用户，依靠的当然是该用户的email属性。如果from_email不提供的话，Django会使用settings中的DEFAULT_FROM_EMAIL发送。 |
| `get_profile()`                               |               | 返回一个和Site相关的profile对象，用来存储额外的用户信息。这个返回值会在另一片博文中详细描述。 |

User对象的Manager，UserManager

和其他的模型一样，User模型类的objects属性也是一个Manager对象，但是User的Manager对象是自定义的，增加了一些方法

```python
create_user(username,email=None,password=None)
# 该方法创建保存一个is_active=True的User对象并返回。username不能够为空，否则抛出ValueError异常。email和password都是可选的。email的domain部分会被自动转变为小写。password如果没有提供，则User对象的set_unusable_password()方法将会被调用。

make_random_password(length=10,allowed_chars='abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789')
# 该方法返回一个给定长度和允许字符集的密码。其中默认的allowed_chars有一些字符没有，比如i,l等等。
```

- 创建User

执行python manage.py shell启动Django的shell

创建User

```shell
>>> from django.contrib.auth.models import User
>>> user = User.objects.create_user('esperyong', 'esperyong@gmail.com', '123456')
# 现在一个is_active属性为True的User对象已经创建并存入数据库中了。
# 接下来我们可以对其属性进行修改，然后存入数据库。
>>> user.is_staff = True
>>> user.save()
```

修改密码

```shell
# 方法一：使用set_password方法进行设置，最后存入数据库的将是进行过hash转换的密文
>>> from django.contrib.auth.models import User
>>> u = User.objects.get(username__exact='esperyong')
>>> u.set_password('new password')
>>> u.save()

# 方法二：用python manage.py changepassword *username*来进行修改，需要输入两次密码

# 注意：不要直接给User的password属性赋值
```

- AnonymousUser

django.contrib.auth.models.AnonymousUser是实现了User接口的类。在用户还没有用权限系统登陆的时候，在request.user中使用的就是该对象，用户可以通过调用is_anonymous()方法来验证是否为匿名用户。

以下是该对象和User对象的差异：

```
id永远是None
is_staff和is_superuser永远为False
groups和user_permissions永远为空
is_anoymous()为True
is_authenticated()为False
set_password(),check_password(),save(),delete(),set_groups()和set_permissions()抛出NotImplementedError.
```

- UserProfile

在Django中，有一种机制可以让你存储和User在某个Site相关的一些信息到一个对象中，这个对象就是UserProfile。

1. 需要定义这个模型，这个模型需要一个和User模型相关的一对一关系属性，如下

```python
rom django.contrib.auth.models import User
 
class UserProfile(models.Model):
    # 和User的一对一关系属性，该属性必填.
    user = models.OneToOneField(User)
 
    # 其他需要存储的属性
    # User因为是Django提供的，如果想要在其上增加一些自己需要的字段和方法，不太好加入，因此UserProfile是达成这个目标的一个有利工具
    accepted_eula = models.BooleanField()
    favorite_animal = models.CharField(max_length=20, default="Dragons.")
```

2. 在settings中声明一个变量，变量名为AUTH_PROFILE_MODULE，值为 appname.profile类名，如下

```
AUTH_PROFILE_MODULE = 'accounts.UserProfile'
```

这样，我们的User对象的get_profile()方法就会返回这个对象了。需要注意的一点是，UserProfile对象不会和User一起自动创建，需要以某种方式自己搞定这件事情。最合理的最Djangoist的方式就是注册一个handler到User的post_save signal了

参阅Django的文档

```python
# 在 models.py
 
from django.contrib.auth.models import User
from django.db.models.signals import post_save
 
# 定义了UserProfile
# ...
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)
 
post_save.connect(create_user_profile, sender=User)
```

### Login/Logout

而在Web应用中，任何的权限系统要做的第一步就是用户识别，也就是我们常说的登陆(login)。只有正确的登陆校验，知道用户是谁了，才能够知道用户能干什么，那就是许可（Permission）需要负责解决的事情，而Group则是批量设置许可的时候的一个便利手段了

- web请求的认证

django有一套方法，可以在每个view方法能够接收到的request对象中增加权限验证相关的方法。需要如下几步

1. 安装SessionMiddleware和AuthenticationMiddleware

```python
# 在settings文件中对MIDDLEWARE_CLASSES变量增加上述两个Middleware类
MIDDLEWARE_CLASSES = (
    'django.contrib.sessions.middleware.SessionMiddleware',  # 新增
    'django.middleware.locale.LocaleMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',  # 新增
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.transaction.TransactionMiddleware',
)
```

2. 在view视图中使用

```python
# 使用request.user获取当前的登陆用户User对象。
# 如果当前用户没有登陆，那么request.user将会是我们之前所说的AnonymousUser对象。
# 我们可以用User对象的is_authenticated()方法将这两者区分开来：
if request.user.is_authenticated():
    # 做一些事情针对验证用户.
else:
    # 做一些事情对于匿名未登录用户.
```

- Login

登陆一个用户需要两个函数：authenticate(username,password)和login(request,user),位于django.contrib.auth模块中；

> authenticate

需要两个参数username，password，如果校验通过则返回User对象，如果校验不通过返回None

```python
from django.contrib.auth import authenticate
user = authenticate(username='john', password='secret')
if user is not None:
    if user.is_active:
        print "You provided a correct username and password!"
    else:
        print "Your account has been disabled!"
else:
    print "Your username and password were incorrect."
```

> login

接受两个参数，第一个是request对象，第二个是user对象。login方法使用SessionMiddleware将userID存入session当中。注意，在用户还未登录的时候，也存在着匿名用户的Session，在其登陆之后，之前在匿名Session中保留的信息，都会保留下来。这两个方法要结合使用，而且必须要先调用authenticate()，因为该方法会User的一个属性上纪录该用户已经通过校验了，这个属性会被随后的login过程所使用

```python
from django.contrib.auth import authenticate, login
 
def my_view(request):
    username = request.POST['username']
    password = request.POST['password']
    user = authenticate(username=username, password=password)
    if user is not None:
        if user.is_active:
            login(request, user)
            # 跳转到成功页面.
        else:
            # 返回一个无效帐户的错误
    else:
        # 返回登录失败页面。
```

我们也可以不用authenticate()进行特定于一个用户的身份校验，直接使用和User无关的几个函数进行密码相关的校验，在Django1.4中以及新版本中提供以下方法，位于模块django.contrib.auth.hashers：

```python
check_password(password,encoded)
# 第一个参数是明文密码，第二个参数是加密过的密码。如果通过校验返回True，不通过返回False
make_password(password[,salt,hashers])
# 根据给定的明文密码，salt，和Django支持的加密算法，返回一个加密的密码。如果password提供的值为None，那么该返回值将永远通不过check_password()方法。这个返回值是一个特定的约定值，目前是'!'
is_password_usable(encoded_password)
# 判断是否给定字符串是一个hashed密码，有机会通过check_password()函数的校验。
```

- logout

使用django.contrib.auth.logout函数来登出用django.contrib.auth.login函数登入的用户。

`logout(requet)`函数只有一个参数，就是request。没有返回值，而且即使当前用户没有登陆也不会抛出任何异常

```python
from django.contrib.auth import logout
 
def logout_view(request):
    logout(request)
    # 重定向到成功登出界面
```

这个方法，会将存储在用户session的数据全部清空，这样避免有人用当前用户的浏览器登陆然后就可以查看当前用户的数据了，回想一下login会保留anonymous用户的session数据。如果需要将一些东西加入到登出之后的用户session，那么需要在logout方法调用之后再进行。

- signals

Django的signal体系是一套简单实用的事件定义、事件产生、事件监听、事件处理框架，具体可以参看Django关于signal的文档。在登陆和登出这两个重要的点上，提供了两个signal：

```
django.contrib.auth.signals.user_logged_in
django.contrib.auth.signals.user_logged_out

# 有三个参数会随singal传过来：
sender：user的class，如果是logout事件该值有可能是None如果用户根本就没有验证通过。
request:HttpRequest对象
user:user对象，如果是logout事件该值有可能是None如果用户根本就没有验证通过。
```

一个经常性的简单需求就是控制某些view（struts中叫做action方法）只对登陆用户开放，如果未登录用户请求该view则跳转到登录界面让其登陆。要做到这一点，我们可以这样做：

```python
from django.http import HttpResponseRedirect
 
def my_view(request):
    if not request.user.is_authenticated():
        return HttpResponseRedirect('/login/?next=%s' % request.path)
    # ...
```

也可以这样做，返回一个错误的页面

```python
def my_view(request):
    if not request.user.is_authenticated():
        return render_to_response('myapp/login_error.html')
    # ...
```

更为优雅的方式是用decorator:

```python
django.contrib.auth.decorators.login_required([redirect_field_name=REDIRECT_FIELD_NAME,login_url=None])
```

login_required()装饰器函数做了以下事情：

```
1. 如果当前用户没有登陆，跳转到settings.LOGIN_URL,并传递当前的绝对路径到URL请求参数中，例如：/accounts/login/?next=/polls/3/
2. 如果当前用户已经登陆了，执行view方法。在view中的方法可以认为当前用户已经登陆了。
```

login_required方法接受两个参数：

```
1. redirect_field_name:默认值是next。用来定义登陆成功之后的跳回之前访问界面的url。
2. login_url:默认值是settings.LOGIN_URL。用来指定登陆界面的url。如果不传入改参数，就需要确保settings.LOGIN_URL的值是正确设置的。
```

没有参数的login_required装饰器使用方法：

```python
from django.contrib.auth.decorators import login_required
 
@login_required
def my_view(request):
    ...
```

传递参数的方法：

```python
from django.contrib.auth.decorators import login_required
 
@login_required(redirect_field_name='my_redirect_field')
def my_view(request):
    ...
from django.contrib.auth.decorators import login_required
 
@login_required(login_url='/accounts/login/')
def my_view(request):
    ...
```

### Permissions/Group

Django中的Permissions设置，主要通过Django自带的Admin界面进行维护。主要通过设置某些用户对应于某类模型的add\change\delete三种类型的权限，即是设置某些人对某些模型能够增加、修改、删除的权限设置。

Permission不仅仅能够设置某类模型，还可以针对一个模型的某一个对象进行设置。

- Permissions

当我们在django中安装好了auth应用之后，Django就会被每一个你安装的app中的Model创建三个权限：add,change,delete;相应的数据，就是在你执行python manage.py syncdb之后插入到数据库中的。每一次你执行syncdb,Django都会为每个用户给新出现的Model增加这三个权限。

例如，你创建了一个应用叫做school,里面有一个模型叫做StudyGroup,那么你可以用任何一个user对象执行下面的程序，其结果都返回True：

```python
user.hash_perm('school.add_studygroup')
user.hash_perm('school.change_studygroup')
user.hash_perm('school.delete_studygroup')
```

当然，我们也可以自己定义一些许可。方法很简单，就是在Model类的meta属性中添加permissions定义。比方说，创建了一个模型类叫做Discussion，我们可以创建几个权限来对这个模型的权限许可进行控制，控制某些人可以发起讨论、发起回复，关闭讨论。

```python
class  Discussion(models.Model):
    ...
    class  Meta:
        permissions = (
            ("open_discussion", "Can create a discussion"),
            ("reply_discussion", "Can reply discussion"),
            ("close_discussion", "Can remove a discussion by setting its status as closed"),
        )
```

接下来要做的就是最后一步，执行manage.py syncdb，这样数据库中就有了这三个许可了。

我们可以将上面的权限赋予用户，方法有两种：

```
1. 通过某一个user的user_permissions属性：
   user.user_permissions.add(permission, permission, ...)
　
2. 通过user的一个组，然后通过Group的permissions属性：
   group.permissions.add(permission, permission, ...)
```

比如我们要判断一个用户是否有发讨论的权限，我们可以用下面的代码：

```
user.has_perm('school.open_discussion')
```

 Permission类和User类没什么特殊的，都是普通的DjangoModel。在第一篇文章中我们详细探讨了User模型的属性和方法。在这里我们探讨一下Permission模型和如何用编程的方式而不是通过预定义然后syncdb的方式创建permission。因为也许在某些时候，需要动态创建并分配权限。

- Permission 属性

所属模块：django.contrib.auth.models

属性：

```
1. name:必填。小于50个字符。例如：'Can publish'。
2. content_type：必填。一个指向django_content_type数据库表，对于每一个Django模型，在这个表里面都有一个记录对应。
3. codename：必填。小于100个字符。例如：'can_publish'。
```

方法：没有特殊方法。具有所有普通DjangoModel的方法。

> 编程创建权限

```python
rom django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType
 
content_type = ContentType.objects.get(app_label='school', model='Discussion')
permission = Permission.objects.create(codename='can_publish',
                                       name='Can Publish Discussions',
                                       content_type=content_type)
```

> 界面中使用许可

在Template（模板）中使用许可。因为有的时候需要在界面上，通过一些许可来控制界面的显示。

在Django中在界面上进行权限设置非常方便，因为Django为你做了很多工作。

在模版代码中，有两个属性，是Django给你提供好的，一个是user，一个是perms。

比方说我们可以这样判断一个用户是否是登陆用户，进而作出不同的显示：

```jinja2
{% if user.is_authenticated %}
    <p>Welcome, {{ user.username }}. Thanks for logging in.</p>
{% else %}
    <p>Welcome, new user. Please log in.</p>
{% endif %}
```

user变量是一个User或者AnoymousUser对象。

perms变量是一个django.contrib.auth.context_processors.PermWrapper对象，对当前用户的User.has_module_perms和User.has_perm进行了封装。这个包装器让你使用perm起来非常的方便。比如，我们需要判断当前用户是否拥有school应用下的所有权限，则使用

`{{perms.school}}`

我们如果判断当前用户是否拥有school应用下发表讨论的权限，则使用{{perms.school.publish_discussion}}

这样结合template的if标签，我们可以通过判断当前用户所具有的权限，显示不同的界面了：

```jinja2
{% if perms.school %}
    <p>You have permission to do something in the school app.</p>
    {% if perms.school.publish_discussion %}
        <p>You can discussion!</p>
    {% endif %}
    {% if perms.school.reply_discussion %}
        <p>You can reply discussion!</p>
    {% endif %}
{% else %}
    <p>You don't have permission to do anything in the school app.</p>
{% endif %}
```

在模版中为何会有这两个变量呢？Django是如何做到的呢？答案是：settings 中的TEMPLATE_CONTEXT_PROCESSORS中定义的django.contrib.auth.context_processors.auth处理器。在Django进入解析Template之前，首先要经过这一个个的context_processor。其中django.contrib.auth.context_processors.auth就是将user和perms这俩对象放到TemplateContext中去的。[``](http://www.cnblogs.com/esperyong/ref/settings.html#std:setting-TEMPLATE_CONTEXT_PROCESSORS)

另外，我们还需要使用RequestContext作为TemplateContext。例如：

```python
from django.template import RequestContext
from django.shortcuts import render_to_response
def someview(request):
    ...view logic
    ctx = {somekey:somevalue}
    return render_to_response('instances/accounts/tparts/update_share_limit_form.html',
                                              ctx,
                                              context_instance=RequestContext(request))
```

- Group

用户组模型很简单，和User模型是多对多的关系。用户组顾名思义，就是对用户进行了分组。其作用在权限控制中就是可以批量的对用户的许可进行分配，而不用一个一个的按用户分配，节省维护的工作量。

将一个用户加入到一个Group中，该用户就拥有了该Group所分配的所有许可。例如，如果一个组teachers有许可can_create_lesson。那么所有属于teachers组的用户都会有这个权限。

Group属性：

```
1. name:必须。少于80个字符。
2. permissions:多对多引用。和user的user_permissions属性类型相同。我们可以通过如下操作给该组赋予权限：
group.permissions = [permission_list]
group.permissions.add(permission, permission, ...)
group.permissions.remove(permission, permission, ...)
group.permissions.clear()
```

### backends

Django实现的这套permission体系，在底层被抽象为authentication backends。Django auth backends的默认的内置的实现，就是我们前4篇blog所描述的，基于三个数据库模型User,Permission,Group。在实际开发中，很有可能我们的用户标示或者是密码并非存在于User表中，比如说存放在LDAP中，再比如使用第三方的OAuth。这就需要我们能够对已有的权限系统进行扩展，而不是局限于基于数据库表的权限控制，这也是Django将其抽象为可以定制的authentication backends的缘由。

Django中，所有的authentication backends，可以通过配置settings中的一个变量AUTHENTICATION_BACKENDS来做到，这个变量的类型是元组（Tuple）,默认Django的设置是：

```
AUTHENTICATION_BACKENDS = ('django.contrib.auth.backends.ModelBackend',)
```

Backend可以是普通的python类，但是关于登陆校验需要具有以下规定的2个方法：

 ```
1. authenticate(self,username=None,password=None) 或者authenticate(self,token=None)，如果通过验证，返回值是一个User对象，如果不通过验证，返回值是None。
2. get_user(self,user_id)
 ```

关于许可，需要有以下几个方法

```
get_group_permissions
get_all_permissions
has_perm
has_module_perms
```

这两类方法的具体使用不是很相同，关于登陆校验的authenticate，Django在使用他们的时候，会遍历所有的auth backends，一旦发现有一个backend校验通过，即返回User对象，那么将会停止下面backend的校验，并且将校验成功的backend绑定在该用户上放入session中，此后如果再次调用该方法，那么将会使用session中的backend进行校验，而不再遍历所有backend了。

而关于许可，一个用户所拥有的perm是所有backends所返回的perm。

最后，我们要提醒一下，虽然has_perm的最后一个参数是一个obj，看上去像是支持每个对象级别的权限校验，而事实上，Django只是在架构和接口上面支持了对象级别的权限校验，但是并没有实现。这意味着，所有关于对象权限的校验方法返回值都是False或者是空列表。因此，如果需要实现Object级别的权限控制，需要自己写或者使用第三方扩展来实现。具体点就是将会接受obj和user_obj，对于每一个auth方法会返回一个关于该用户针对于该对象的一个权限控制结果。

### object级别

Django默认并没有提供对Object级别的权限控制，而只是在架构上留了口子。在这篇blog中，我们探讨一个简单流行的Django组件django-guardian来实现Object level permission。

- 安装配置django-guardian

首先需要安装django-guardian,一般我们喜欢用virtualenv创建一个虚拟环境

```
>>virtualenv --distribute venv
>>source venv/bin/activate
>>pip install Django
>>pip install django-guardian
```

在INSTALLED_APPS变量中加入guardian:

```
INSTALLED_APPS = (
    'guardian',
)
```

然后，如果仔细读过《Django中内置的权限控制》的第五篇文章的读者，应该猜到，我们需要添加一个backend到AUTHENTICATION_BACKENDS中，这样django才会具有对对象的权限控制：

```
AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend', # django默认的backend
    'guardian.backends.ObjectPermissionBackend',
)
```

在guardian中，还支持对匿名用户AnoymousUser的Object级别的权限控制，这种需求很常见，比方说允许匿名发言的论坛或者blog系统。要做到这一点需要在settings中加入：

```
ANONYMOUS_USER_ID=-1
```

接下来我们执行python manage syncdb.执行完毕之后，系统将会创建一个User实例，叫做AnonymouseUser。完成了以上几点，guardian就被安装好了，可以开始使用了。

- 设置和使用对象权限

首先当然是设置和使用对象权限了，guardian提供了一个简单的方法：

```
guardian.shortcuts.assign(perm, user_or_group, obj=None)

# 参数
perm,这个参数是一个字符串，代表一个许可，格式必须为<app>.<perm_codename>或者<perm_codename>。但是如果第三个参数是None，则必须为<app>.<perm_codename>格式。因此建议还是统一使用<app>.<perm_codename>格式。注意app并不是app的全路径，而是最后一级的模块名。这一点和INSTALL_APP中的app全路径不同，如果你的app module不只一级的话，这地方一定要注意。
user_or_group，这个参数是一个User或者Group类型的对象。
obj，这个参数就是相关的对象了。改参数是可省略的，如果省略则赋予Model权限
```

通过这个方法我们可以很方便通过传入一个<app>.<perm_codename>格式的字符串来给用户User或组Group赋予权限了。如果不传入第三个参数，则可以当作User.user_permissions.add(permissioninstance) 的快捷方式。

下面是赋予模型级别的权限

```
from guardian.shortcuts import assign
user = User.objects.create(username='liuyong')
assign('app.view_task', user)
user.has_perm('app.view_task') >>True
```

注意，一旦赋予模型级的权限，那么所有该模型的对象级别的权限就都有了，所以应该先从对象级别进行设置，清空刚刚分配的权限然后再设置对象权限：

```
user = User.objects.get(username='liuyong')
user.user_permissions.clear()
task = Task.objects.create(summary='Some job', content='')
assign('app.view_task', user, task)
user = User.objects.get(username='liuyong')#刷新缓存
user.has_perm('app.view_task',task)
>>True
user.has_perm('app.view_task')#模型级别的权限还没有
>>False
```

也可以通过设置group来使用户具有相应的权限

```
>>> group = Group.objects.create(name='employees')
>>> assign('change_task', group, task)
>>> user.has_perm('change_task', task)
False
>>> # user还不是employees组的成员,我们加入一下
>>> user.groups.add(group)
>>> user.has_perm('change_task', task)
True
```

接下来是删除某个用户对某个对象的某种许可，我们需要使用guardian.shortcuts模块中的remove_perm()函数。这个函数的签名和assign相同，都是三个:

```
guardian.shortcuts.remove_perm(perm,user_or_group=None, obj=None)
```

样例代码

```
>>> from guardian.shortcuts import remove_perm
>>> remove_perm('change_site', user, site)
>>> user = User.objects.get(username='joe') #刷新user对象缓存
>>> joe.has_perm('change_site', site)
False
```

- view中使用

除了Django的user.has_perm方法之外，guardian提供了一些帮助函数能让我们生活的更轻松。

```
guardian.shortcuts.get_perms(user_or_group,obj)
```

该方法返回user对象对obj对象所有的权限。这个行数接受两个参数，一个是user对象或者组对象，一个是相关的对象。

比如我们可以用`permcodename' in get_perms(group,obj)`来判断该组是否有这个权限，因为group没有has_perm方法。

```
guardian.shortcuts.get_objects_for_user(user, perms, klass=None, use_groups=True, any_perm=False)
```

该函数获得该用户下指定perm列表中的所有对象。比如我要获得某一个用户，拥有编辑权限的所有帖子。`
get_objects_for_user(user,'app.change_post')
`

```
guadian.core.ObjectPermissionChecker
```

该方法是一个用来判断权限的包装器，针对user和group提供权限相关的访问方法，主要有has_perm(perm,obj)和get_perms(obj)两个方法。并且提供缓存机制，在多次查找权限的时候，可以使用它

```
>>> epser = User.objects.get(username='esper')
>>> site = Site.objects.get_current()
>>> from guardian.core import ObjectPermissionChecker
>>> checker = ObjectPermissionChecker(esper) # 我们也可以传入组group对象
>>> checker.has_perm('change_site', site)
True
>>> checker.has_perm('add_site', site) # 这次将不会产生数据库查询
False
>>> checker.get_perms(site)
[u'change_site']
```

> view的decorator

以使用decorator来减少我们的代码，通过decorator控制一个view函数的访问。我们要做到的是，只有拥有对name=foobars的Group对象拥有auth.change_group权限的用户，才能够执行这个view函数，否则返回的将是状态码为403的Response对象

```shell
>>> joe = User.objects.get(username='joe')
>>> foobars = Group.objects.create(name='foobars')
>>>
>>> from guardian.decorators import permission_required_or_403
>>> from django.http import HttpResponse
>>>
>>> @permission_required_or_403('auth.change_group',
>>>     (Group, 'name', 'group_name'))
>>> def edit_group(request, group_name):
>>>     return HttpResponse('some form')
>>>
>>> from django.http import HttpRequest
>>> request = HttpRequest()
>>> request.user = joe
>>> edit_group(request, group_name='foobars')
<django.http.HttpResponseForbidden object at 0x102b43dd0>
>>>
>>> joe.groups.add(foobars)
>>> edit_group(request, group_name='foobars')
<django.http.HttpResponseForbidden object at 0x102b43e50>
>>>
>>> from guardian.shortcuts import assign
>>> assign('auth.change_group', joe, foobars)
<UserObjectPermission: foobars | joe | change_group>
>>>
>>> edit_group(request, group_name='foobars')
<django.http.HttpResponse object at 0x102b8c8d0>
>>> # 这时，我们已经分配了权限，因此我们的view方法得以顺利访问了。
```

- 模版中的使用

和Django一样，我们也需要在界面上进行权限控制以显示不同的界面。Guardian提供了标签`get_obj_perms`，需要加载guardian_tags标签库，在需要使用guardian标签的模版上面，将其引用进来`{% load guardian_tags %}`

标签格式

```
{% get_obj_perms user/group for obj as "context_var" %}
```

样例

```
{% get_obj_perms request.user for flatpage as "flatpage_perms" %}
 
{% if "delete_flatpage" in flatpage_perms %}
    <a href="/pages/delete?target={{ flatpage.url }}">Remove page</a>
{% endif %}
```

- 孤儿对象许可（Orphaned object permissions）

所谓孤儿许可，就是没用的许可。在大多数情况下，可能没啥事儿，但是一旦发生，后果有可能非常严重。

Guardian用来纪录某用户对某个模型对象有某个权限的纪录时是使用UserObjectPermission和GroupObjectPermission对象纪录的。其中对于object的引用是contenttype对象（标示是那个模型类）和pk主键，对于用户则是对User表的外键引用。

比方说，有一个对象A。我们通过权限设置，设定joe用户对该对象有着编辑权限。忽然有一天，用户joe被删除了。可想而知，我们分配而产生的UserObjectPermission对象仍然在数据库里面，记录着：joe 有对A的编辑权限。又有一天，一个用户注册了一个用户，用户username为joe。因为之前的那个纪录，joe用户拥有对A的编辑权限。而此joe非彼joe，我们犯了一个大错误！

再比如说，当我们删除了某一个对象的时候，而这个对象的某种权限已经被赋予给某个用户，那么这个权限的纪录也就失效了。如果什么时候和曾经删除过的对象是同一个模型类，而且主键和以前的那个相同，那么用户也就有可能对其本不应该拥有权限的对象有了权限。呵呵，说起来有点绕，但是应该很容易理解。

因此，当我们删除User和相关的Object的时候，我们一定要删除其相关的所有UserObjectPermission和GroupObjectPermission对象。

要解决这个办法有三个办法，一个是显式编码，一个是通过其提供的自定义django命令：

```
python manage.py clean_orphan_obj_perms
```

还有一个是定期调用`guardian.utils.``clean_orphan_obj_perms()`

该函数会返回删除的对象数目。在python的世界中，我们可以使用celery定期调度这个任务。

但是自定义命令和定期调度都不是合理的生产环境的解决办法。要想真正解决，还是需要手动编码实现，最优雅的方式还是加上post_delete signal给User或Object对象，关于对象的样例代码如下：

```python
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.db.models import Q
from django.db.models.signals import pre_delete
from guardian.models import UserObjectPermission
from guardian.models import GroupObjectPermission
from school.models import StudyGroup
 
 
def remove_obj_perms_connected_with_user(sender, instance, **kwargs):
    filters = Q(content_type=ContentType.objects.get_for_model(instance),
        object_pk=instance.pk)
    UserObjectPermission.objects.filter(filters).delete()
    GroupObjectPermission.objects.filter(filters).delete()
 
pre_delete.connect(remove_obj_perms_connected_with_user, sender=StudyGroup)
```

## 