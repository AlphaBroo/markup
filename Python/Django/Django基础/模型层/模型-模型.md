[TOC]

# 模型

ORM Object relational mapping 对象关系映射

- 自动生成的数据库表
- 以面向对象的方式操作数据库数据
- 通过方便的配置，切换使用不同的数据库

## 创建模型类

模型是你的数据的唯一的、权威的信息源。它包含你所储存数据的必要字段和行为。通常，每个模型对应数据库中唯一的一张表。

基础

```
- 每个模型都是django.db.models.Model的一个Python 子类。
- 模型的每个属性都表示为数据库中的一个字段。
- Django 提供一套自动生成的用于数据库访问的API
```

示例


```python
from django.db import models

#定义图书模型类BookInfo
class BookInfo(models.Model):
    btitle = models.CharField(max_length=20)#图书名称
    bpub_date = models.DateField()#发布日期
    bread = models.IntegerField(default=0)#阅读量
    bcomment = models.IntegerField(default=0)#评论量
    isDelete = models.BooleanField(default=False)#逻辑删除
    class Meta:
      db_table = 'book_info'  # 表名
      
      
#定义英雄模型类HeroInfo
class HeroInfo(models.Model):
    hname = models.CharField(max_length=20)#英雄姓名
    hgender = models.BooleanField(default=True)#英雄性别
    isDelete = models.BooleanField(default=False)#逻辑删除
    hcomment = models.CharField(max_length=200)#英雄描述信息
    hbook = models.ForeignKey('BookInfo')#英雄与图书表的关系为一对多，所以属性定义在英雄模型类中
    class Meta:
      db_table = 'hero_info'  # 表名
```

### 字段

```
我们导入from django.db import models

在模型类中，定义属性，生成对应的数据库表字段
属性名 = models.字段类型(字段选项)

属性名命名限制
不能是python的保留关键字。
不允许使用连续的下划线，这是由django的查询方式决定的。
```

####  字段类型

模型中的每个字段都应该是相应的`Field`类的实例。 Django使用字段类来确定一些事情

```
- 列类型，它告诉数据库要存储什么样的数据（例如INTEGER，VARCHAR，TEXT）。
- 呈现表单字段时使用的默认HTML widget（例如<input type="text">, <select>）
- Django管理员和自动生成的表单中使用的最小验证要求。
```

注意： 只要修改了表字段的类型，就需要重新生成迁移文件并执行迁移操作。

| 类型                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| AutoField                | 自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性，若是指定了其他列为primary_key，则不会自动添加id列 |
| BooleanField             | 布尔字段，值为True或False                                    |
| NullBooleanField         | 支持Null、True、False三种值                                  |
| CharField                | 字符串，参数`max_length`(必填)表示最大字符个数               |
| TextField                | 大文本字段，一般超过4000个字符时使用                         |
| IntegerField             | 整数                                                         |
| PositiveIntegerField     | 0和正整数                                                    |
| CommaSeparatedInterField | 逗号分隔的整数字段，参数`max_length`(必填)表示最大长度       |
| DecimalField             | 使用python的`Decimal`实例表示的十进制浮点数， 参数`max_digits`(必填)表示总位数， 参数`decimal_places`(必填)表示小数位数 |
| FloatField               | 使用python的`float`实例表示的浮点数                          |
| DateField                | 使用python的`datetime.date`实例表示的日期。<br/> 参数`auto_now`表示每次保存对象时，自动设置该字段为当前时间，默认为False； 参数`auto_now_add`表示当对象第一次被创建时自动设置当前时间，默认为False; 参数auto_now_add和auto_now是相互排斥的，组合将会发生错误 |
| TimeField                | 使用python的`datetime.time`实例表示时间，参数同DateField     |
| DateTimeField            | 使用python的`datetime.datetime`实例表示的日期时间，参数同DateField |
| UUIDField                | 使用python的`UUID`类，用来存储UUID字段。使用UUID类型相对于使用具有`primary_key`参数的`AutoField`类型是一个更好的解决方案 |
| URLField                 | 一个CharField类型的URL，接收`max_length`参数，若无，则默认值200 |
| EmailField               | 邮件，一个`CharField`用来检查输入地址是否合法，它使用`EmailValidator`来验证输入合法性 |
| GenericIPAddressField    | 一个 IPv4 或 IPv6 地址, 字符串格式                           |
| FileField                | 上传文件字段, 不支持primary_key和unique                      |
| ImageField               | 继承于FileField，对上传的内容进行校验，确保是有效的图片      |

[官方更多字段类型说明](https://yiyibooks.cn/xx/django_182/ref/models/fields.html#model-field-types)

类型对照(mysql)

| 数据库字段类型 | 模型类字段类型 | python数据类型    |
| -------------- | -------------- | ----------------- |
| datetime       | DatetimeFiled  | datetime.datetime |
| date           | DateFiled      | dateteime.date    |
| decimal        | Decimal        | Decimal           |
| char(32)       | UUIDField      | UUID              |

示例

AutoField

```python
# 默认情况下，Django为每个模型提供以下字段，是一个自动递增的主键
# 如果自定义主键，只需在其中一个字段上指定primary_key = True即可。 如果Django看到你明确设置了Field.primary_key，它不会添加自动id列。
id = models.AutoField(primary_key=True)
```

Datetime

```python
# datetime.datetime类型
datetime.datetime.now(),
# 转换为字符串：
datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
# dateteime.date类型
datetime.datetime.strptime('1999-01-01', "%Y-%m-%d").date()


class Good(models.Model):
  create_time = models.DatetimeField('添加时间', auto_now_add=True, blank=True)
```

FileField和ImageField

```python
# 在模型中调用需要如下几步
1. 在你的settings文件中, 你必须要定义 MEDIA_ROOT 作为Django存储上传文件的路径(从性能上考虑，这些文件不能存在数据库中。) 定义一个 MEDIA_URL 作为基础的URL或者目录。确保这个目录可以被web server使用的账户写入。
2. 在模型中添加FileField 或 ImageField 字段, 定义 upload_to参数，内容是 MEDIA_ROOT 的子目录，用来存放上传的文件。
3. 数据库中存放的仅是这个文件的路径 （相对于MEDIA_ROOT). 你很可能会想用由Django提供的便利的url 属性。比如说, 如果你的ImageField 命名为 mug_shot, 你可以在template中用 {{ object.mug_shot.url }}获得你照片的绝对路径。
例如，如果你的 MEDIA_ROOT设定为 '/home/media'，并且 upload_to设定为 'photos/%Y/%m/%d'。 upload_to的'%Y/%m/%d'被strftime()所格式化；'%Y' 将会被格式化为一个四位数的年份, '%m' 被格式化为一个两位数的月份'%d'是两位数日份。如果你在Jan.15.2007上传了一个文件，它将被保存在/home/media/photos/2007/01/15目录下.

如果你想获得上传文件的存盘文件名，或者是文件大小，你可以分别使用 name 和 size 属性； 更多可用属性及方法信息，请参见 File 类索引 和 Managing files 主题指导.
```

UUIDField

```python
import uuid
from django.db import models

class MyUUIDModel(models.Model):
    # 这里传递给default是一个可调用的对象（即一个省略了括号的方法），而不是传递一个UUID实例给default
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields
```

#### 字段选项

每个字段都有一组特定于字段的参数，通过选项实现对数据库表字段的约束：

| 选项        | 默认值   | 描述                                                         | 是否要重新迁移修改表结构 |
| ----------- | -------- | ------------------------------------------------------------ | ------------------------ |
| null        | False    | 如果为True，Django将在数据库中将空值存储为NULL。对于CharFIeld和TextField避免使用，它们存储空字符串而不是null | 是                       |
| blank       | False    | 若为True，则该字段允许为空白，表单验证时将允许输入空值，为False则该字段必填。是表单数据验证范畴，null为数据库范畴 |                          |
| choices     |          | 是一个迭代结构(列表或元组)，由可迭代的二元组组成,用来给这个字段提供选择项 |                          |
| default     |          | 默认值，可以时一个值或一个可调用对象(不可变),若是可调用对象,则每次创新对象时,将会调用一次 |                          |
| unique      | False    | True表示这个字段在表中必须有唯一值                           | 是                       |
| db_column   | 属性名称 | 字段名，如果未指定，则使用属性的名称                         | 是                       |
| db_index    | False    | 若值为True, 则在表中会为此字段创建索引                       | 是                       |
| primary_key | False    | 若为True，则该字段会成为模型的主键字段。若没有指定任何字段，则Django自动添加AutoField字段来充当主键。若指定了其他列，则不再默认创建Id列 | 是                       |

[更多字段选项](https://yiyibooks.cn/xx/django_182/ref/models/fields.html)

示例

Choice

```python
# 定义
from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),  # 第一个元素是存储在数据库中的值，第二个元素由字段的表单小部件显示
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
    
# 查看choice
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()  # 模型实例.get_FOO_diaplay()访问显示值
'Large'
```

default

```python
# 这个默认值不可以是一个可变对象（如字典，列表，等等）,因为对于所有模型的一个新的实例来说，它们指向同一个引用。或者，把他们包装为一个可调用的对象。
# 注意lambdas 函数不可作为如 default 这类可选参数的值.因为它们无法被 migrations命令序列化
def contact_default():
    return {"email": "to1@example.com"}

contact_info = JSONField("ContactInfo", default=contact_default)
```

Primary_key

```python
# 主键是只读的，若更改现有对象上主键的值并保存它，则会在旧对象旁边创建一个新对象
from django.db import models

class Fruit(models.Model):
    name = models.CharField(max_length=100, primary_key=True)
    
# 操作
>>> fruit = Fruit.objects.create(name='Apple')
>>> fruit.name = 'Pear'
>>> fruit.save()
>>> Fruit.objects.values_list('name', flat=True)
<QuerySet ['Apple', 'Pear']>
```

#### 字段名称

除了`ForeignKey`、`ManyToManyField`和`OneToOneField`外，每种字段类型都有一个可选的第一个位置参数 - 一个详细名称。 如果没有给出详细名称，Django将使用该字段的属性名称自动创建它，并将下划线转换为空格。

```python
# 字段名称person's first name
first_name = models.CharField("person's first name", max_length=30)
# 字段名称first name
first_name = models.CharField(max_length=30)
```

在`ForeignKey`、`ManyToManyField`和`OneToOneField`中，第一个参数为模型类，因此请使用`verbose_name`关键字参数。约定不是要大写`verbose_name`的第一个字母。 Django会自动把它需要的第一个字母大写。

```python
poll = models.ForeignKey(
    Poll,
    on_delete=models.CASCADE,
    verbose_name="the related poll",
)
sites = models.ManyToManyField(Site, verbose_name="list of sites")
place = models.OneToOneField(
    Place,
    on_delete=models.CASCADE,
    verbose_name="related place",
)
```

#### 关系字段

| 类型             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| ForeignKey       | 多对一关系，需要两个位置参数：与该模型关联的类和`on_delete`选项 。若要创建一个递归的关系。参数为`self`。会自动创建数据库索引，可设置`db_index`为False取消 |
| ManayToManyField | 一个多对多关联。要求一个关键字参数：与该模型关联的类，与`ForeignKey`的工作方式完全一样，包括递归关系和惰性关系。不建议从一个没有迁移的应用中创建一个`ManyToManyField`到一个具有迁移的应用。关联的对象可以通过字段的`RelatedManager`添加、删除和创建。 |
| OneToOneField    | 一对一关联关系。概念上讲，这个字段很像是`ForeignKey`设置了`unique=True`，不同的是它会直接返回关系另一边的单个对象。主要的用途是作为扩展自另外一个模型的主键；例如，[*多表继承*](https://yiyibooks.cn/__trs__/xx/django_182/topics/db/models.html#multi-table-inheritance)就是通过对子模型添加一个隐式的一对一关联关系到父模型实现的。需要一个位置参数：与该模型关联的类。 它的工作方式与`ForeignKey`完全一致，包括所有与递归关系和惰性关系相关的选项。若没有指定`OneToOneField` 的`related_name`参数，Django 将使用当前模型的小写的名称作为默认值。 |

##### ForeignKey

- 定义

```python
from django.db import models

class Catalog(models.Model):
  	# 创建递归关系
  	parent = models.ForeignKey('self', on_delete=models.CASCADE)

class Car(models.Model):
  	# 关联到一个还没有定义的模型
    manufacturer = models.ForeignKey('Manufacturer'， on_delete=models.CASCADE)
    # 关联一个其他应用中定义的模型，可以使用完整的应用程序标签明确指定一个模型
    manufacturer = models.ForeignKey('production.Manufacturer'， on_delete=models.CASCADE)
    # 关联到一个已经定义的模型
		manufacturer = models.ForeignKey(Manufacturer， on_delete=models.CASCADE)
    
class Manufacturer(models.Model):
    # ...
    pass
 
class AbstractCar(models.Model):
  	# 当模型被作为具体模型进行子类化并且与抽象模型的app_label不相关时，在抽象模型上以这种方式定义的关系被解析
    manufacturer = models.ForeignKey('Manufacturer', on_delete=models.CASCADE)

    class Meta:
        abstract = True
```

- 数据库显示

```
Django会在字段名上添加"_id" 来创建数据库中的列名。

若不需要添加id，则在参数中指定db_column的字段名
```

- 参数

| name                 | Desc                                                         |
| -------------------- | ------------------------------------------------------------ |
| `on_delete`          | 当删除`ForeignKey`引用的对象时，Django将模拟`on_delete`参数指定的SQL约束的行为 |
| `limit_choices_to`   | 使用`ModelForm`或admin（默认情况下，可以选择查询集中的所有对象）呈现此字段时，为此字段的可用选项设置限制。 可以使用字典，`Q`对象或返回字典或`Q`对象的可调用对象。 |
| `related_name`       | 从相关对象返回到这个关系的名称。 它也是`related_query_name`（用于来自目标模型的反向过滤器名称的名称）的默认值。 有请注意，在定义抽象模型上的关系时必须设置此值；当你这样做时一些特殊的语法可用。 |
| `related_query_name` | 用于来自目标模型的反向过滤器名称的名称。 如果设置，它默认为`related_name`或`default_related_name`的值，否则默认为模型的名称 |
| `to_field`           | 系所涉及的相关对象上的字段。 默认情况下，Django使用相关对象的主键。 如果引用其他字段，则该字段必须具有`unique = True`。 |
| `db_constraint`      | 控制是否应在数据库中为此外键创建约束。 默认值为`True`，这几乎可以肯定你想要的；将此设置为`False`对于数据完整性可能非常糟糕。 也就是说，这里有一些你可能想要这样做的场景：遗留数据无效、正在分片数据库。如果将此值设置为`False`，则访问不存在的相关对象将引发其`DoesNotExist`异常。 |
| `swappable`          | 如果此`ForeignKey`指向可交换模型，则控制迁移框架的反应。 如果它是`True` - 默认值 - 那么如果`ForeignKey`指向与`settings.AUTH_USER_MODEL`（或另一个）的当前值匹配的模型可交换模型设置）关系将使用对设置的引用存储在迁移中，而不是直接存储在模型中。 如果您确定模型应始终指向交换模型，则只希望将其覆盖为`False` - 例如，如果它是专门为您的自定义用户模型设计的配置文件模型。将其设置为`False`并不意味着您可以引用可交换模型，即使它被换出 - `False`只是意味着使用此ForeignKey进行的迁移将始终引用确切的模型您指定（例如，如果用户尝试使用您不支持的用户模型运行，则会很难失败）。 |

`on_delete`

```python
# 如果您有一个可为空的ForeignKey，并且您希望在删除引用的对象时将其设置为null：
user = models.ForeignKey(
    User,
    models.SET_NULL,
    blank=True,
    null=True,
)

# 可能值
CASCADE  			级联，模拟SQL约束ON DELETE CASCADE行为，并删除包含ForeignKey的对象。
PROTECT				保护，通过抛出ProtectedError异常，来防止删除引用的对象
SET_NULL			设置为NULL，仅在该字段null=True允许为null时可用
SET_DEFAULT		设置为默认值，仅在该字段设置了默认值时可用
SET()					将ForeignKey设置为传递给SET()的值，或者如果传入了callable，则调用它的结果。在大多数情况下，为了避免在导入models.py时执行查询，必须传递callable
DO_NOTHING		不采取行动。 如果数据库后端强制实施参照完整性，则会导致IntegrityError，除非您手动添加SQL ON DELETE约束到数据库字段。

# 示例
from django.conf import settings
from django.contrib.auth import get_user_model
from django.db import models

def get_sentinel_user():
    return get_user_model().objects.get_or_create(username='deleted')[0]

class MyModel(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET(get_sentinel_user),
    )
```

`limit_choices_to`

```python
# 字典
staff_member = models.ForeignKey(
    User,
    on_delete=models.CASCADE,
    limit_choices_to={'is_staff': True},  # 导致ModelForm上的相应字段仅列出is_staff = True的用户。 这在Django管理员中可能会有所帮助。
)

def limit_pub_date_choices():
    return {'pub_date__lte': datetime.date.utcnow()}  # 可以限制按日期范围进行选择

limit_choices_to = limit_pub_date_choices

# Q对象
如果limit_choices_to是或返回Q 对象，这对于复杂查询 ，那么只有在该模型的ModelAdmin的raw_id_fields中未列出该字段时，它才会对管理员的选择产生影响。
# 可调用对象
可调用对象用于limit_choices_to，它将在每次新实例化一个新表单时被调用。 它也可能在模型验证时被调用，例如通过管理命令或管理员。 admin构造查询集以多次验证其在各种边界情况下的表单输入，因此可能会多次调用您的可调用对象。
```

`related_name`

```python
# 如果你希望Django不要创建向后关系，请将related_name设置为'+'或者以'+'结束
user = models.ForeignKey(
    User,
    on_delete=models.CASCADE,
    related_name='+',  # 确保User模型不会与此模型有倒退关系：
)
```

`related_query_name`

```python
# Declare the ForeignKey with related_query_name
class Tag(models.Model):
    article = models.ForeignKey(
        Article,
        on_delete=models.CASCADE,
        related_name="tags",
        related_query_name="tag",
    )
    name = models.CharField(max_length=255)

# That's now the name of the reverse filter
Article.objects.filter(tag__name="important")
```

##### ManayToManyField

- 定义

```python
from django.db import models

class Person(models.Model):
		# 自关联
    friends = models.ManyToManyField("self")
    
class Topping(models.Model):
    # ...
    pass

class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)  # 哪个模型具有ManyToManyField并不重要，但您应该只将其放在其中一个模型中 - 而不是两者。   
```

- 数据库表示

```
在幕后，Django 创建一个中间表来表示多对多关系。
默认情况下，这张中间表的名称使用多对多字段的名称和包含这张表的模型的名称生成。因为某些数据库支持的表的名字的长度有限制，这些表的名称将自动截短到64个字符并加上一个唯一性的哈希值。这意味着，你看的表的名称可能类似 author_books_9cdf4；这再正常不过了。你可以使用db_table 选项手工提供中间表的名称。
```

- 参数

| name                 | desc                                                         |
| -------------------- | ------------------------------------------------------------ |
| `related_name`       | 类似ForeignKey中                                             |
| `related_query_name` | 类似ForeignKey中                                             |
| `limit_choices_to`   | 类似ForeignKey中，`limit_choices_to` 对于使用`through`参数自定义中间表的`ManyToManyField` 不生效。 |
| `symmetrical`        | 只用于与自身进行关联的ManyToManyField                        |
| `through`            | Django 会自动创建一个表来管理多对多关系。不过，如果你希望手动指定中介表，可以使用`through`选项来指定Django 模型来表示你想要使用的中介表。这个选项最常见的使用场景是当你想要关联*额外的数据到多对多关联关系*的时候。 |
| `through_fields`     | 只能在指定了自定义中间模型的时候使用。 Django 一般情况会自动决定使用中间模型的哪些字段来建立多对多关联 |
| `db_table`           | 为存储多对多数据而创建的表的名称。如果没有提供，Django 将基于定义关联关系的模型和字段假设一个默认的名称。 |
| `db_constraint`      | 控制中间表中的外键是否创建约束。默认为`True`，而且这是几乎就是你想要的；设置为`False` 对数据完整性将非常糟糕。下面是你可能需要这样设置的一些场景:具有不合法的遗留数据、正在对数据库缩容。不可以同时传递`db_constraint` 和 `through`. |
| `swappable`          | 控制`ManyToManyField` 指向一个可切换的模型时迁移框架的行为。如果它是默认值`True`，那么如果`ManyToManyField`指向的模型与`settings.AUTH_USER_MODEL` 匹配（或其它可切换的模型），则保存在迁移中的关联关系将使用对setting 中引用而不是直接对模型的引用。只有当你确定你的模型将永远指向切换后的模型 —— 例如如果它是专门为你的自定义用户模型设计的模型时，你才会想将它设置成`False`。如果不确定，请将它保留为`True`。 |

`symmetrical`

```
当Django处理自关联模型的时候，它定义该模型具有一个与自身具有多对多关联的ManyToManyField，因此它不会向Person 类添加person_set 属性。Django 将假定这个ManyToManyField 字段是对称的。

如果你希望与self 进行多对多关联的关系不具有对称性，可以设置symmetrical 为False。这会强制让Django 添加一个描述器给反向的关联关系，以使得ManyToManyField 的关联关系不是对称的。
```

`through`

```python
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=128)

    def __str__(self):
        return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership')

    def __str__(self):
        return self.name

class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)

# 中间模型有几个限制：
- 您的中间模型必须包含一个-并且只有一个-源模型的外键（在我们的示例中，这将是Group），或者您必须显式指定外键Django应该使用ManyToManyField.through_fields用于关系。 如果您有多个外键，并且未指定through_fields，则会引发验证错误。 类似的限制适用于目标模型的外键（在我们的例子中，这将是Person）。
- 对于通过中间模型与自身有多对多关系的模型，允许使用同一模型的两个外键，但它们将被视为多对多关系的两个（不同）方面。 如果还有多于两个外键，那么还必须像上面那样指定through_fields，否则会引发验证错误。
- 当使用中间模型定义从模型到其自身的多对多关系时，您必须使用symmetrical = False（请参阅模型字段参考）。

# 如果你没有显式指定through 的模型，仍然会有一个隐式的through模型类，你可以用它来直接访问对应的表示关联关系的数据库表。它由三个字段来链接模型。
- 如果源模型和目标不同，则生成以下字段：
id：关系的主键。
<containing_model>_id：声明ManyToManyField 字段的模型的id。
<other_model>_id：ManyToManyField 字段指向的模型的id。

- 如果ManyToManyField 的源模型和目标模型相同，则生成以下字段：
id：关系的主键。
from_<model>_id：源模型实例的id。
to_<model>_id：目标模型实例的id。

这个类可以让一个给定的模型像普通的模型那样查询与之相关联的记录。
```

`through_fields`

```python
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=50)

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(
        Person,
        through='Membership',
      	# through_fields 接收一个二元组('field1', 'field2')，其中field1 为指向定义ManyToManyField 字段的模型的外键名称（本例中为group），field2 为指向目标模型的外键的名称（本例中为person）。
        through_fields=('group', 'person'),
    )

class Membership(models.Model):
  	# 有两个外键指向Person,这使得关联关系含混不清并让Django不知道使用哪一个。在这种情况下，你必须使用through_fields 明确指定Django应该使用哪些外键
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    inviter = models.ForeignKey(
        Person,
        on_delete=models.CASCADE,
        related_name="membership_invites",
    )
    invite_reason = models.CharField(max_length=64)
    
    
# 当中间模型具有多个外键指向多对多关联关系模型中的任何一个（或两个），你必须 指定through_fields。当用到中间模型而有多个外键指向该模型时，或当你想显式指定Django应该用到两个字段中的某个时，这也用适用于递归的关联关系。

# 递归的关联关系使用的中间模型始终定义为非对称的，也就是symmetrical=False —— 所以具有源和目标的概念。这种情况下，'field1' 将作为管理关系的源，而'field2' 作为目标    
```

##### OneToOneField

- 定义

```python
from django.conf import settings
from django.db import models

class MySpecialUser(models.Model):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
    )
    supervisor = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='supervisor_of',
    )
```

特性

```shell
# 使得User模型具有以下属性
>>> user = User.objects.get(pk=1)
>>> hasattr(user, 'myspecialuser')
True
>>> hasattr(user, 'supervisor_of')
True

# 当反向访问关联关系时，如果关联的对象不存在对应的实例，则抛出DoesNotExist 异常。
# 例如，如果一个User 没有MySpecialUser 指定的supervisor：
>>> user.supervisor_of
Traceback (most recent call last):
    ...
DoesNotExist: User matching query does not exist.
```

- 参数

| name                 | desc                                                         |
| -------------------- | ------------------------------------------------------------ |
| ForeignKey的所有参数 |                                                              |
| `parent_link`        | 当它为`True` 并在继承自另一个具体模型的模型中使用时，表示该字段应该用于反查的父类的链接，而不是在子类化时隐式创建的`OneToOneField`。 |

### 元选项

使用嵌套类 `class Meta`来指定你所定义模型的元数据，型的元数据是指“任何不是字段”的设置，比如“排序”选项 (`ordering`), 数据库表名(`db_table`), 或者人可读（对人友好）的名称（单/复数形式）。(`verbose_name` and `verbose_name_plural`). 都是可以不设置的，而且整个`class Meta` 嵌套类都是完全可选的。

```python
from django.db import models
from django.db.models import F

class Ox(models.Model):
    horn_length = models.IntegerField()

    class Meta:
      	app_label = 'myapp'
        db_table = 'ox_demo'
        get_latest_by = "order_date"
        ordering = ['-pub_date', F('author').asc(nulls_last=True)] # 2.0
        verbose_name_plural = "oxen"     
```

可用选项

| name                    | desc                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `abstract`              | 设置为True，表示模型是抽象类                                 |
| `app_label`             | 如果model是在`INSTALLED_APPS`中的应用程序之外定义的，则它必须声明它属于哪个应用程序 |
| `base_manager_name`     | 模型的`_base_manager`的管理器的名称                          |
| `db_table`              | 模型所使用的在数据库中表的名称。如果未指明，Django默认以 `应用名小写_模型类名小写` 为数据库表名 |
| `db_tablespace`         | 当前模型所使用的[*数据库表空间*](https://yiyibooks.cn/__trs__/xx/django_182/topics/db/tablespaces.html) 的名字。默认值是项目设置中的[`DEFAULT_TABLESPACE`](https://yiyibooks.cn/__trs__/xx/django_182/ref/settings.html#std:setting-DEFAULT_TABLESPACE)，如果它存在的话。如果后端并不支持表空间，这个选项可以忽略。 |
| `default_related_name`  | 这个名字会默认被用于一个关联对象到当前对象的关系。默认为`<model_name>_set`。 |
| `get_latest_by`         | 模型中某个可排序的字段的名称，比如`DateField`、`DateTimeField`或者`IntegerField`。它指定了[`Manager`](https://yiyibooks.cn/__trs__/xx/django_182/topics/db/managers.html#django.db.models.Manager)的[`latest()`](https://yiyibooks.cn/__trs__/xx/django_182/ref/models/querysets.html#django.db.models.query.QuerySet.latest)和[`earliest()`](https://yiyibooks.cn/__trs__/xx/django_182/ref/models/querysets.html#django.db.models.query.QuerySet.earliest)中使用的默认字段。 |
| `managed`               | 默认为`True`，意思是Django在[`migrate`](https://yiyibooks.cn/__trs__/xx/django_182/ref/django-admin.html#django-admin-migrate)命令中创建合适的数据表，并且会在 [`flush`](https://yiyibooks.cn/__trs__/xx/django_182/ref/django-admin.html#django-admin-flush) 管理命令中移除它们。换句话说，Django会*管理*这些数据表的生命周期。如果是`False`，Django 就不会为当前模型创建和删除数据表。如果当前模型表示一个已经存在的，通过其它方法建立的数据库视图或者数据表，这会相当有用。这是设置为`managed=False`时*唯一*的不同之处。 |
| `order_with_respect_to` | 按照给定的字段把这个对象标记为”可排序的“。这一属性通常用到关联对象上面，使它在父对象中有序。它会添加一个额外的字段（/数据表中的列）叫做`_order`，不能用与`ordering`同用 |
| `ordering`              | 对象默认的顺序，获取一个对象的列表时使用。它是一个字符串的列表或元组。每个字符串是一个字段名，前面带有可选的“-”前缀表示倒序。前面没有“-”的字段表示正序。使用"?"来表示随机排序。2.0中增加支持查询表达式 |
| `permissions`           | 设置创建对象时权限表中额外的权限。增加、删除和修改权限会自动为每个模型创建。它是一个包含二元组的元组或者列表，格式为 `(permission_code,human_readable_permission_name)`。 |
| `default_permissions`   | 默认为`('add', 'change', 'delete')`。你可以自定义这个列表，比如，如果你的应用不需要默认权限中的任何一项，可以把它设置成空列表。在模型被`migrate`命令创建之前，这个属性必须被指定，以防一些遗漏的属性被创建。 |
| `proxy`                 | 如果`proxy = True`, 它作为另一个模型的子类，将会作为一个[*代理模型*](https://yiyibooks.cn/__trs__/xx/django_182/topics/db/models.html#proxy-models)。 |
| `required_db_features`  | 当前连接应具有的数据库功能列表，以便在迁移阶段考虑模型。例如，如果将此列表设置为['gis_enabled']，则模型将仅在启用GIS的数据库上同步。在使用多个数据库后端进行测试时跳过某些模型也很有用。避免可能会或可能不会创建的模型之间的关系，因为ORM无法处理此问题 |
| `required_db_vendor`    | 此模型特定的受支持数据库供应商的名称。目前的内置供应商名称是：sqlite，postgresql，mysql，oracle。如果此属性不为空且当前连接供应商与其不匹配，则不会同步模型。 |
| `select_on_save`        | 该选项决定了Django是否采用1.6之前的保存算法                  |
| `indexes`               | 要在模型上定义的索引列表。1.11新增                           |
| `unique_together`       | 集体在模型中的字段必须是唯一的。在Django Admin只能够被使用，在数据库级别强制执行。 |
| `index_together`        | 集体在模型中的字段上创建的索引，可被`indexes`替代            |
| `verbose_name`          | 对象的人类可读名称，单数。如果此项没有设置，Django会把类名拆分开来作为自述名，比如`CamelCase` 会变成`camel case`， |
| `verbose_name_plural`   | 该对象复数形式的名称。如果此项没有设置，Django 会使用 `verbose_name` + `"s"` |

`managed`

```
模型处理的其它任何方面都和平常一样。这包括：

如果你不声明它的话，会向你的模型中添加一个自增主键。为了避免给后面的代码读者带来混乱，强烈推荐你在使用未被管理的模型时，指定数据表中所有的列。

如果一个带有managed=False的模型含有指向其他未被管理模型的ManyToManyField，那么多对多连接的中介表也不会被创建。但是，一个被管理模型和一个未被管理模型之间的中介表会被创建。

如果你需要修改这一默认行为，创建中介表作为显式的模型（设置为managed），并且使用ManyToManyField.through为你的自定义模型创建关联。

对于带有managed=False的模型的测试，你要确保在测试启动时建立正确的表。

如果你对修改模型类在Python层面的行为感兴趣，你可以设置 managed=False ，并且为一个已经存在的模型创建一个副本。但是这种情况下使用代理模型才是更好的方法
```

`order_with_respect_to`

```python
from django.db import models

class Question(models.Model):
    text = models.TextField()
    # ...

class Answer(models.Model):
    question = models.ForeignKey(Question)
    # ...

    class Meta:
        order_with_respect_to = 'question'
        
# 使用
# 当order_with_respect_to 设置之后，模型会提供两个用于设置和获取关联对象顺序的方法：get_RELATED_order() 和set_RELATED_order()，其中RELATED是小写的模型名称。例如，假设一个 Question 对象有很多相关联的Answer对象，返回的列表中含有与之相关联Answer对象的主键：
>>> question = Question.objects.get(id=1)
>>> question.get_answer_order()
[1, 2, 3]
# 与Question对象相关联的Answer对象的顺序，可以通过传入一格包含Answer 主键的列表来设置：
>>> question.set_answer_order([3, 1, 2])
# 相关联的对象也有两个方法， get_next_in_order() 和get_previous_in_order()，用于按照合适的顺序访问它们。假设Answer对象按照 id来排序：
>>> answer = Answer.objects.get(id=2)
>>> answer.get_next_in_order()
<Answer: 3>
>>> answer.get_previous_in_order()
<Answer: 1>
```

`permissions`

```python
permissions = (("can_deliver_pizzas", "Can deliver pizzas"),)
```

`indexes`

```python
from django.db import models

class Customer(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)

    class Meta:
        indexes = [
            models.Index(fields=['last_name', 'first_name']),
            models.Index(fields=['first_name'], name='first_name_idx'),
        ]
```

`unique_together`

```python
# 元组中的数据必须唯一
unique_together = (("driver", "restaurant"),)
# 可简写
unique_together = ("driver", "restaurant")
```

`index_together`

```python
index_together = [["pub_date", "deadline"]]
# 可简写
index_together = ["pub_date", "deadline"]
```

### 方法属性

#### 属性

```python
objects		
# 管理器，是models.Manager类型的对象，用于与数据库进行交互。
# 每个非抽象的Model 类必须给自己添加一个Manager实例。Django 确保在你的模型类中至少有一个默认的Manager。如果你没有添加自己的Manager，Django 将添加一个属性objects，它包含默认的Manager 实例。如果你添加自己的Manager实例的属性，默认值则不会出现
```

示例

```python
from django.db import models

class Person(models.Model):
    # Add manager with another name
    people = models.Manager()
```

#### 自动生成方法

| name                 | desc                                                         |
| -------------------- | ------------------------------------------------------------ |
| `__str__()`          | 无论何时调用对象上的`str()`，都会调用`__str__()`方法。 Django在很多地方使用`str（obj）`。 最值得注意的是，在Django管理站点中显示对象，并在显示对象时将其作为插入到模板中的值。 因此，您应该始终从`__str__()`方法返回一个漂亮的，人类可读的模型表示。 |
| `__eq__()`           | 定义这个方法是为了让具有相同主键的相同实类的实例是相等的。对于代理模型而言，实类被定义为该模型的第一个非代理父类；而对于其它模型而言，实类就是该模型的类 |
| `__hash()__`         | `__hash__()`方法基于实例的主键值。 它实际上是`hash(obj.pk)`。 如果实例没有主键值，那么将引发一个`TypeError`（否则`__hash__()`方法将在实例保存之前和之后返回不同的值，但在Python中禁止更改实例的`__hash__()`值。 |
| `get_absolute_url()` | 定义一个`get_absolute_url()`方法来告诉Django如何计算一个对象的规范URL。 对于调用者来说，这个方法似乎应该返回一个可以用来通过HTTP引用对象的字符串。 |
| `create()`           | 创建模型的新实例。关键字参数只是在模型上定义的字段的名称。 请注意，实例化模型不会触及数据库；为此，您需要`save()` |
| `save()`             |                                                              |
| `delete()`           |                                                              |

示例

```python
# __str__
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)

    def __str__(self):
        return '%s %s' % (self.first_name, self.last_name)
      
# __eq__
from django.db import models

class MyModel(models.Model):
    id = models.AutoField(primary_key=True)

class MyProxyModel(MyModel):
    class Meta:
        proxy = True

class MultitableInherited(MyModel):
    pass

# Primary keys compared
MyModel(id=1) == MyModel(id=1)
MyModel(id=1) != MyModel(id=2)
# Primay keys are None
MyModel(id=None) != MyModel(id=None)
# Same instance
instance = MyModel(id=None)
instance == instance
# Proxy model
MyModel(id=1) == MyProxyModel(id=1)
# Multi-table inheritance
MyModel(id=1) != MultitableInherited(id=1)

# get_absolute_url
def get_absolute_url(self):
    return "/people/%i/" % self.id
  
def get_absolute_url(self):
    from django.urls import reverse
    return reverse('people.views.details', args=[str(self.id)])
```

#### 重写内置方法

create

```python
# 您可能会试图通过重写__ init __方法来定制模型。 但是，如果您这样做，请注意不要更改调用签名，因为任何更改都可能会阻止保存模型实例。 不要重写__ init __，请尝试使用以下方法之一：
# 方法一：在模型类上添加一个classmethod
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=100)

    @classmethod
    def create(cls, title):
        book = cls(title=title)
        # do something with the book
        return book

book = Book.create("Pride and Prejudice")
# 方法二：在自定义管理器中添加一个方法（通常是首选）
class BookManager(models.Manager):
    def create_book(self, title):
        book = self.create(title=title)
        # do something with the book
        return book

class Book(models.Model):
    title = models.CharField(max_length=100)

    objects = BookManager()

book = Book.objects.create_book("Pride and Prejudice")
```

save

```python
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, *args, **kwargs):
        do_something()
        super().save(*args, **kwargs)  # Call the "real" save() method.
        do_something_else()
   
  	# 阻止保存
    def save(self, *args, **kwargs):
        if self.name == "Yoko Ono's blog":
            return # Yoko shall never have her own blog!
        else:
            super().save(*args, **kwargs)  # Call the "real" save() method.
```

#### 自定义方法

可以在模型上定义自定义的方法来给你的对象添加自定义的“底层”功能。Manager 方法用于“表范围”的事务，模型的方法应该着眼于特定的模型实例。这是一个非常有价值的技术，让业务逻辑位于同一个地方 —— 模型中。

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    @property
    def full_name(self):  # 属性
        "Returns the person's full name."
        return '%s %s' % (self.first_name, self.last_name)
```

### 跨文件的模型

访问其他应用的模型是非常容易的。 在文件顶部你定义模型的地方，导入相关的模型来实现它。然后，无论在哪里需要的话，都可以引用它。

```python
from django.db import models
from geography.models import ZipCode

class Restaurant(models.Model):
    # ...
    zip_code = models.ForeignKey(ZipCode)
```

### 模型的继承

定义的模型类应该继承`django.db.models.Model`。

在Django 中有3种风格的继承。

```
- 抽象基类 只想使用父类来持有一些信息，你不想在每个子模型中都敲一遍。这个类永远不会单独使用，所以你要使用抽象基类
- 多表继承 如果你继承一个已经存在的模型且想让每个模型具有它自己的数据库表，那么应该使用多表继承
- 代理模型 只是想改变一个模块Python级别的行为，而不用修改模型的字段，你可以使用代理模型
```

#### 抽象继承

抽象类被用来作为一个其他model的基类时，它的字段将被加入那些子类中。如果抽象基类和它的子类有相同的字段名，那么将会出现error（并且Django将抛出一个exception）。

它提供一种在 Python 语言层级上提取公共信息的方式，同时在数据库层级上，每个子类各自仍然只创建一个数据库表。

```python
from django.db import models

class CommonInfo(models.Model):
  	# 模型不会被用来创建任何数据表，无法拥有一个管理器，不能示例话或直接存储
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True  

class Student(CommonInfo):
    home_group = models.CharField(max_length=5)
```

- Meta继承

当一个抽象基类被创建的时候, Django会把你在基类内部定义的 Meta类作为一个属性使用。如果子类没有声明自己的Meta类, 他将会继承父类的Meta. 如果子类想要扩展父类的Meta类，它可以作为其子类。

```python
from django.db import models

class CommonInfo(models.Model):
    # ...
    class Meta:
        abstract = True
        ordering = ['name']

class Student(CommonInfo):
    # ...
    class Meta(CommonInfo.Meta):
        db_table = 'student_info'
```

继承时，Django 会对抽象基类的Meta类做一个调整：在设置Meta属性之前，Django 会设置 `abstract=False`。这意味着抽象基类的子类本身不会自动变成抽象类。 当然，你可以让一个抽象基类继承自另一个抽象基类，你只要记得每次都要显式地设置 `abstract=True`。

- Related_name/related_query_name

如果你在 `ForeignKey`或  `ManyToManyField`字段上使用  `related_name`或`related_query_name`，则必须始终指定*unique*字段的反向名称和查询名称。 在抽象基类中使用通常会导致问题，因为此类的字段包含在每个子类中，并且属性的值完全相同（包括`related_name`和`related_query_name `）。

要解决此问题，在抽象基类（仅）中使用`related_name`或`related_query_name`时，部分值应包含`'％(app_label)s'`和`'％(class)s'`

```
'%(class)s' 会替换为子类的小写加下划线格式的名称，字段在子类中使用。

'%(app_label)s' 会替换为应用的小写加下划线格式的名称，应用包含子类。每个已安装的应用程序名称必须是唯一的，并且每个应用程序中的模型类名称也必须是唯一的，因此结果名称最终会有所不同。
```

示例

```python
# common/models.py
class Base(models.Model):
    m2m = models.ManyToManyField(
        OtherModel,
        related_name="%(app_label)s_%(class)s_related",
        related_query_name="%(app_label)s_%(class)ss",
    )

    class Meta:
        abstract = True

class ChildA(Base):
    pass

class ChildB(Base):
    pass
    
# rare/models.py
from common.models import Base

class ChildB(Base):
    pass
```

说明

```
ommon.ChildA.m2m字段的反向名称将为common_childa_related，反向查询名称将为common_childas。 common.ChildB.m2m字段的反向名称将为common_childb_related，反向查询名称为common_childbs。 最后，rare.ChildB.m2m字段的反向名称将为rare_childb_related，反向查询名称将为rare_childbs。 这取决于您如何使用'%(class)s'和'%(app_label)s'部分来构造相关名称或相关查询名称，但如果您忘记使用它，Django会在执行系统检查时引发错误（或运行migrate）。

如果您没有为抽象基类中的字段指定related_name属性，则默认的反向名称将是子类的名称，后跟'_ set'，就像通常直接在子类上声明字段一样。 例如，在上面的代码中，如果related_name属性被省略，则m2m字段在ChildA中的反向名称为childa_set 而在ChildB中为childb_set。
```

#### 多表继承

使用这种继承方式时，每一个层级下的每个 model 都是一个真正意义上完整的 model 。 每个 model 都有专属的数据表，都可以查询和创建数据表。 继承关系在子 model 和它的每个父类之间都添加一个链接 (通过一个自动创建的`OneToOneField`来实现)

```python
from django.db import models

class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)

class Restaurant(Place):
    serves_hot_dogs = models.BooleanField(default=False)
    serves_pizza = models.BooleanField(default=False)
```

`Place`里面的所有字段在 Restaurant中也是有效的，只不过没有保存在数据库中的`Restaurant`表中。以下语句可以运行

```shell
>>> Place.objects.filter(name="Bob's Cafe")
>>> Restaurant.objects.filter(name="Bob's Cafe")
```

如果你有一个 `Place` ，它同时也是一个 `Restaurant`， 那么你可以使用 model 的小写形式从 `Place` 对象中获得与其对应的`Restaurant`对象：

```shell
>>> p = Place.objects.get(id=12)
# If p is a Restaurant object, this will give the child class:
>>> p.restaurant
<Restaurant: ...>
```

但是，如果上例中的 `p` 并*不是*  `Restaurant` (比如它仅仅只是 `Place`对象，或者它是其他类的父类)，那么在引用 `p.restaurant`就会抛出`Restaurant.DoesNotExist` 异常。

- Meta

在多表继承中，子类继承父类的 Meta类是没什么意义的。所有的Meta选项已经对父类起了作用，再次使用只会起反作用。(这与使用抽象基类的情况正好相反，因为抽象基类并没有属于它自己的内容)

所以子 model 并不能访问它父类的 Meta类。但是在某些受限的情况下，子类可以从父类继承某些 Meta ：如果子类没有指定 `ordering`属性或 `get_latest_by`属性，它就会从父类中继承这些属性。

如果父类有了排序设置，而你并不想让子类有任何排序设置，你就可以显式地禁用排序：

```python
class ChildModel(ParentModel):
    # ...
    class Meta:
        # Remove parent's ordering effect
        ordering = []
```

- 继承与反向关联

为多表继承使用了一个隐含的 `OneToOneField`来链接子类与父类，所以象上例那样，你可以用父类来指代子类。但是这个 OnetoOneField 字段默认的 `related_name`值与 `ForeignKey`和`ManyToManyField` 默认的反向名称相同。如果你与该父类的另一个子类做多对一或是多对多关系，你就**必须**在每个多对一和多对多字段上强制指定 `related_name`。如果你没这么做，Django 就会在你运行 验证(validation)  时抛出异常。

仍以上面 `Place`类为例，我们创建一个带有`ManyToManyField`字段的子类

```python
class Supplier(Place):
  	# 会产生一个错误
    customers = models.ManyToManyField(Place)
    # 解决错误
    # customers = models.ManyToManyField(Place, related_name='provider')
```

- 指定链接父类的字段

Django 会自动创建一个 `OneToOneField`字段将子类链接至非抽象的父 model 。如果你想指定链接父类的属性名称，你可以创建你自己的 `OneToOneField`字段并设置 `parent_link=True`，从而使用该字段链接父类。

#### 代理继承

有时，你可能只想更改 model 在 Python 层的行为实现。比如：更改默认的 manager ，或是添加一个新方法。正是代理继承要做的：为原始模型创建一个*代理* 。你可以创建，删除，更新代理 model 的实例，而且所有的数据都可以像使用原始 model 一样被保存。 不同之处在于：你可以在代理 model 中改变默认的排序设置和默认的 manager ，更不会对原始 model 产生影响。

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

class MyPerson(Person):
    class Meta:
        proxy = True  # 声明代理model

    def do_something(self):  # 添加了一个方法
        # ...
        pass
      
class OrderedPerson(Person):
  	class Meta:
      ordering = ["last_name"]  # 普通的Person查询是无序的，而 OrderedPerson查询会按照last_name排序
      proxy = True
```

`MyPerson`类和它的父类 `Person` 操作同一个数据表。特别的是，`Person` 的任何实例也可以通过 `MyPerson`访问，反之亦然：

```shell
>>> p = Person.objects.create(first_name="foobar")
>>> MyPerson.objects.get(first_name="foobar")
<MyPerson: foobar>
```

- 查询集始终返回请求的模型

也就是说，没有办法让django在查询`Person`对象时返回`MyPerson`对象。`Person` 对象的查询集会返回相同类型的对象。代理对象的要点是：它会使用依赖于原生`Person`的代码，而你可以使用你添加进来的扩展对象（它不会依赖其它任何代码）。而并不是将`Person`模型（或者其它）在所有地方替换为其它你自己创建的模型。

- 基类的限制

代理模型必须继承自一个非抽象基类。 你不能继承自多个非抽象基类，这是因为一个代理 model 不能连接不同的数据表。 代理 model 也可以继承任意多个抽象基类，但前提是它们*没有* 定义任何 model 字段。

- 代理模型的管理器

如果你没有在代理 模型中定义任何管理器 ，代理模型就会从父类中继承管理器 。 如果你在代理模型中定义了一个管理器 ，它就会变成默认的管理器 ，不过定义在父类中的管理器仍然有效。

改变默认管理器

```python
from django.db import models

class NewManager(models.Manager):
    # ...
    pass

class MyPerson(Person):
    objects = NewManager()

    class Meta:
        proxy = True
```

创建自定义管理器

```python
# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
    secondary = NewManager()

    class Meta:
        abstract = True

class MyPerson(Person, ExtraManagers):  # 继承事把他放在主基类后面
    class Meta:
        proxy = True
```

- 代理模型与非托管模型之间的差异

代理模型继承与在`Meta`类中使用 `managed` 属性的非托管 model 看起来很相似。但两者并不相同，使用时选用哪种方案是一个值得考虑的问题。

 不同之处

```
- 第一个不同之处是：除非你想得到一个空 model，你就需要在指定了`Meta.managed=False` 的模型中定义字段。当你创建映射到一个已存在模型的非托管model，并且向它添加python方法时，你需要谨慎设置`Meta.db_table` ，但是，当你改变了一些东西，需要保证这两个model同步时，这种做法是相当冗余和脆弱的

- 另一个不同之处是两者对管理器的处理方式不同。 代理 model 要与它所代理的 model 行为相似，所以代理 model 要继承父 model 的 managers ，包括它的默认 manager 。 但在普通的多表继承中，子类不能继承父类的 manager ，这是因为在处理非基类字段时，父类的 manager 未必适用。
```

一般规则是：

1. 如果你要借鉴一个已有的 模型或数据表，且不想涉及所有的原始数据表的列，那就令 `Meta.managed=False`。通常情况下，对模型数据库创建视图和表格不需要由 Django 控制时，就使用这个选项。
2. 如果你想对 model 做 Python 层级的改动，又想保留字段不变，那就令 `Meta.proxy=True`。因此在数据保存时，代理 model 相当于完全复制了原始 模型的存储结构

#### 多重继承

就像Python的子类那样，django的模型可以继承自多个父类模型。切记一般的Python名称解析规则也会适用。出现特定名称的第一个基类(比如Meta)是所使用的那个。例如，这意味着如果多个父类含有 Meta类，只有第一个会被使用，剩下的会忽略掉。

一般来说，你并不需要继承多个父类。多重继承主要对“mix-in”类有用：向每个继承mix-in的类添加一个特定的、额外的字段或者方法。

注意：多重继承含有一个共同的id主键会产生错误，为此，可以在模型基类中使用显式的使用AutoFIeld

```python
class Article(models.Model):
    article_id = models.AutoField(primary_key=True)
    ...

class Book(models.Model):
    book_id = models.AutoField(primary_key=True)
    ...

class BookReview(Book, Article):
    pass
```

或者私用一个祖先类来持有AutoFiled，这需要使用从每个父模型到公共祖先的显式OneToOneField来避免子项自动生成和继承的字段之间的冲突：

```python
class Piece(models.Model):
    pass

class Article(Piece):
    article_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
    ...

class Book(Piece):
    book_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
    ...

class BookReview(Book, Article):
    pass
```

### 组织模型类

`manage.py startapp`命令创建一个包含models.py文件的应用程序结构。如果您有许多模型，则在单独的文件中组织它们可能很有用。

为此，可以创建一个models包，删除models.py，创建一个带有`__init__.py`的文件夹`myapp/models/`

```python
# myapp/models/__init__.py
from .organic import Person
from .synthetic import Robot
```



## 使用模型类

改配置文件中的`INSTALLED_APPS` 设置，在其中添加`models.py`所在应用的名称

```python
# settings.py
INSTALLED_APPS = (
    #...
    'myapp',
    #...
)
```

当你在INSTALLED_APPS 中添加新的应用名时，请确保运行命令`manage.py migrate`，可以事先使用`manage.pymakemigrations` 给应用生成迁移脚本。