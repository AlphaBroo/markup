# 视图-视图函数

一个视图函数，简称*视图*，是一个简单的Python 函数，它接受Web请求并且返回Web响应。响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片. . . 是任何东西都可以。无论视图本身包含什么逻辑，都要返回响应。代码写在哪里也无所谓，只要它在你的Python目录下面。

## 简单视图

```python
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()  # 注意时区在settings中TIME_ZONE设置，默认America/Chicago
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
```

## 内置视图

###  开发环境中的文件服务器

```
static.serve(request, path, document_root, show_indexes=False)
```

在本地的开发环境中，除了你的项目中的静态文件，可能还有一些文件，出于方便，你希望让Django 来作为服务器。`serve()`视图可以用来作为任意目录的服务器。（该视图**不**能用于生产环境，应该只用于开发时辅助使用；在生产环境中你应该使用一个真实的前端Web 服务器来服务这些文件）

如：用户上传文档到`MEDIA_ROOT`中。`django.contrib.staticfiles` 用于静态文件且没有对用户上传的文件做处理，但是你可以通过在URLconf 中添加一些内容来让Django 作为`MEDIA_ROOT`的服务器：

```python
from django.conf import settings
from django.views.static import serve

# ... the rest of your URLconf goes here ...

if settings.DEBUG:
    urlpatterns += [
        url(r'^media/(?P<path>.*)$', serve, {
            'document_root': settings.MEDIA_ROOT,
        }),
   ]
    
# 注意
这里的代码片段假设你的MEDIA_URL的值为'/media/'。它将调用serve() 视图，传递来自URLconf 的路径和（必选的）document_root 参数。

因为定义这个URL 模式显得有些笨拙，Django 提供一个小巧的URL 辅助函数static()，它接收MEDIA_URL这样的参数作为前缀和视图的路径如'django.views.static.serve'。其它任何函数参数都将透明地传递给视图。
```

### 错误视图

- 404(page not found)

```
defaults.page_not_found(request, exception, template_name='404.html')
```

当你在一个视图中引发`Http404`时，Django 将加载一个专门的视图用于处理404 错误。默认为`django.views.defaults.page_not_found()` 视图，它产生一个非常简单的“Not Found” 消息或者渲染`404.html`模板，如果你在根模板目录下创建了它的话。

默认的404 视图将传递一个变量给模板：`request_path`，它是导致错误的URL。

需要注意

```python
- 如果Django在检测URLconf中的每个正则表达式后没有找到匹配的内容也将调用404视图。
- 404 视图会被传递一个RequestContext并且可以访问模板上下文处理器提供的变量（例如MEDIA_URL）。
- 如果DEBUG设置为True（在你的settings 模块中）,那么将永远不会调用404视图，而是显示你的URLconf 并带有 一些调试信息。
```

- 500(server error)

```
defaults.server_error(request, template_name='500.html')
```

在视图代码中出现运行时错误，Django 将执行特殊情况下的行为。如果一个视图导致异常，Django 默认情况下将调用`django.views.defaults.server_error` 视图，它产生一个非常简单的“Server Error” 消息或者渲染`500.html`，如果你在你的根模板目录下定义了它的话。

默认的500 视图不会传递变量给`500.html` 模板，且使用一个空`Context` 来渲染以减少再次出现错误的可能性。

如果`DEBUG`设置为`True`（在你的settings 模块中），那么将永远不会调用500 视图，而是显示回溯并带有一些调试信息。

- 403(HTTP Forbidden)

```
defaults.permission_denied(request, exception, template_name='403.html')
```

如果一个视图导致一个403 视图，那么Django 将默认调用`django.views.defaults.permission_denied`视图。

该视图加载并渲染你的根模板目录下的`403.html`，如果这个文件不存在则根据RFC 2616（HTTP 1.1 Specification）返回“403 Forbidden”文本。

```python
# django.views.defaults.permission_denied 通过PermissionDenied 异常触发
from django.core.exceptions import PermissionDenied

def edit(request, pk):
    if not request.user.is_staff:
        raise PermissionDenied  # 要拒绝访问一个视图
    # ...
```

- 400(bad request)

```
defaults.bad_request(request, exception, template_name='400.html')
```

当Django 中引发一个`SuspiciousOperation`时，它可能通过Django 的一个组件处理（例如重设会话的数据）。如果没有特殊处理，Django 将认为当前的请求是一个'bad request' 而不是一个server error。

`django.views.defaults.bad_request` 和`server_error`视图非常相似，除了返回400 状态码来表示错误来自客户端的操作。

`bad_request` 视图同样只是在`DEBUG` 为`False` 时使用。

## 返回错误

### 普通`HttpResponse`

```python
from django.http import HttpResponse

def my_view(request):
    # ...
    return HttpResponse('<h1>Page was found</h1>')  # 状态码200，返回html页面
    return HttpResponse(status=201)  # 直接返回状态码201
```

###  `HttpResponse`子类

| name                            | desc                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| `HttpResponseRedirect`          | 重定向，返回一个found重定向，状态码302                       |
| `HttpResponsePermanentRedirect` | 重定向，返回一个永久重定向，状态码301                        |
| `HttpResponseNotModified`       | 构造函数不会有任何的参数，并且不应该向这个响应（response）中加入内容（content）。使用此选项可指定自用户上次请求以来尚未修改页面，状态代码304 |
| `HttpResponseBadRequest`        | 与`HttpResponse`的行为类似，但是状态码400                    |
| `HttpResponseNotFound`          | 与`HttpResponse`的行为类似，但是状态码404                    |
| `HttpResponseForbidden`         | 与`HttpResponse`的行为类似，但是状态码403                    |
| `HttpResponseNotAllowed`        | 与`HttpResponse`的行为类似，构造函数的第一个参数是必须的：一个允许使用的方法构成的列表（例如，`['GET', 'POST']`），但是状态码405 |
| `HttpResponseGone`              | 与`HttpResponse`的行为类似，但是状态码410                    |
| `HttpResponseServerError`       | 与`HttpResponse`的行为类似，但是状态码500                    |

示例

```python
from django.http import HttpResponseNotFound

def my_view(request):
    # ...
    return HttpResponseNotFound('<h1>Page not found</h1>')
```

### 内置异常视图

| name      | desc |
| --------- | ---- |
| `Http404` |      |

示例

```python
from django.http import Http404
from django.shortcuts import render_to_response
from polls.models import Poll

def detail(request, poll_id):
    try:
        p = Poll.objects.get(pk=poll_id)
    except Poll.DoesNotExist:
        raise Http404("Poll does not exist")  
    return render_to_response('polls/detail.html', {'poll': p})
  
# Django提供了Http404异常。如果你在视图函数中的任何地方抛出Http404异常，Django都会捕获它，并且带上HTTP404错误码返回你应用的标准错误页面
# 如果你在抛出Http404异常时提供了一条消息，当DEBUG为True时它会出现在标准404模板的展示中。你可以将这些消息用于调试；但他们通常不适用于404模板本身。
```

### 自定义错误视图

如果你需要任何自定义行为，重写它很容易。只要在你的URLconf中指定下面的处理器（在其他任何地方设置它们不会有效）。

```python
# handler404覆盖page_not_found()视图
handler404 = 'mysite.views.my_custom_page_not_found_view'
# handler500覆盖server_error()视图
handler500 = 'mysite.views.my_custom_error_view'
# handler403覆盖permission_denied()视图
handler403 = 'mysite.views.my_custom_permission_denied_view'
# handler404覆盖bad_request()视图
handler400 = 'mysite.views.my_custom_bad_request_view'
```

