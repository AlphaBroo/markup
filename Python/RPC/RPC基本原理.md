# RPC基本原理

## RPC简介

- 定义

**远程过程调用**（英语：**Remote Procedure Call**，缩写为 **RPC**，也叫**远程程序调用**）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作**远程调用**或**远程方法调用**。

<img src="images/RPC示意图.png" alt="RPC示意图" style="zoom:50%;" />

- 背景用途

在单台计算机中，我们可以通过程序调用来传递控制和数据；或者说通过程序调用，我们可以将多个程序组成一个整体来实现某个功能。

如果将这种调用机制推广到多台彼此间可以进行网络通讯的计算机，由多台计算机中的多个程序组成一个整体来实现某个功能，这也是可以的。调用的一方（发起远程过程调用，然后调用这方的环境挂起，参数通过网络传递给被调用方，被调用的一方执行程序，当程序执行完成后，产生的结果再通过网络回传给调用的一方，调用的一方恢复继续执行。这样一种原型思想，就是我们所说的RPC远程过程调用。

<img src="images/单机到多机.png" alt="单机到多机" style="zoom:50%;" />

RPC这种思想最早可以追溯到1976年，RPC的发展到今天已经40年有余了。

如今的计算机应用中，单机性能上很难承受住产品的压力，需要不断扩充多台机器来提升整体的性能。同时为了充分利用这些集群里的计算机，需要对其从架构上进行划分，以提供不同的服务，服务间相互调用完成整个产品的功能。RPC就能帮助我们解决这些服务间的信息传递和调用。

- 概念说明

> 广义

我们可以将所有通过网络来进行通讯调用的实现统称为RPC。

按照这样来理解的话，那我们发现HTTP其实也算是一种RPC实现。

<img src="images/HTTP.png" alt="HTTP" style="zoom:50%;" />

> 狭义

区别于HTTP的实现方式，在传输的数据格式上和传输的控制上独立实现。比如在机器间通讯传输的数据不采用HTTP协议的方式（分为起始行、header、body三部份），而是使用自定义格式的二进制方式。

我们更多时候谈到的RPC都是指代这种狭义上的理解。

- 优缺点

相比于传统HTTP的实现而言：

优点
```
- 效率高
- 发起RPC调用的一方，在编写代码时可忽略RPC的具体实现，如同编写本地函数调用一样
```
缺点
```
- 通用性不如HTTP好 因为传输的数据不是HTTP协议格式，所以调用双方需要专门实现的通信库，对于不同的编程开发语言，都要有相关实现。而HTTP作为一个标准协议，大部分的语言都已有相关的实现，通用性更好。
```
HTTP更多的面向用户与产品服务器的通讯。

RPC更多的面向产品内部服务器间的通讯。

## RPC结构

RPC的设计思想是力图**使远程调用中的通讯细节对于使用者透明**，调用双方无需关心网络通讯的具体实现。因而实现RPC要进行一定的封装。

RPC原理上是按如下结构流程进行实现的。

<img src="images/RPC结构.png" alt="RPC结构" style="zoom:50%;" />

流程

```
1. 调用者（Caller, 也叫客户端、Client）以本地调用的方式发起调用；
2. Client stub（客户端存根，可理解为辅助助手）收到调用后，负责将被调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体；
3. Client stub将消息体通过网络发送给对端（服务端）
4. Server stub（服务端存根，同样可理解为辅助助手）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数；
5. Server stub根据方法名和参数进行本地调用；
6. 被调用者（Callee，也叫Server）本地调用执行后将结果返回给server stub;
7. Server stub将返回值打包编码成消息，并通过网络发送给对端（客户端）；
8. Client stub收到消息后，进行拆包解码，返回给Client；
9. Client得到本次RPC调用的最终结果。
```

**RPC的目标就是要2~8这些步骤都封装起来，让使用者对这些细节透明。**

在了解了RPC流程之后，为了实现RPC，我们还需要关注两点：

**消息协议**

客户端调用的参数和服务端的返回值这些在网络上传输的数据以何种方式打包编码和拆包解码。

我们可以使用HTTP协议中关于报文格式的规定（如此一来，就编程了HTTP通讯），也可以自己定义某种格式，让客户端与服务端双方都遵循此种格式。

**传输控制**

在网络中数据的收发传输控制具体如何实现。

## 消息协议

在实现RPC调用时，通讯双方传输的数据（消息）如何表达描述，设计时一般会考虑两个**目标**：

**性能高**

性能高包括两点：

1. 将原始数据转换为消息数据的速度快
2. 转换后的消息数据体积小

**跨语言**

RPC调用没有要求调用双方的编程语言必须相同，如果能做到跨语言调用是最好，这会方便产品开发中不同的功能服务以最合适的语言实现，然后使用RPC实现彼此调用。因此RPC调用中传输的消息数据应该尽量能让跟多的语言支持。

**本课程中仅以Python为例进行讲解。**

- 边界

在网络传输中，一方可能连续向另一方多次发送消息，收到数据的一方如何界定数据中包含几条消息，这便是消息边界问题。

考虑TCP传输控制协议，在一条TCP链接中可以多次发送数据，如果发送的数据过大，就会被TCP底层实现拆解为多个数据包依次发送；而如果发送的数据过小，又可能会将几条数据组装成一个数据包进行发送。

为了解决消息边界的问题，有两种较为常用的方法：**分割符法**和**长度声明法**。

> 分隔符法

顾名思义，就是在每条消息的结尾放置一种特殊的分割符（一种常用的分割符是\r\n），表示已到达本条消息的末尾。

<img src="images/特殊分割符.png" alt="特殊分割符" style="zoom:50%;" />

> 长度声明法

长度声明法是在消息的起始位置，用一个固定长度的整数值（通常为4字节）声明本消息的长度，接收者先读取出长度声明，再按照声明的长度读取出相应大小的数据即可。

<img src="images/长度声明.png" alt="长度声明" style="zoom:50%;" />

例如，HTTP协议同时运用了这两种方法：
```javascript
HTTP/1.0 200 OK\r\n
Server: Nginx\r\n
Content-Type: text/html; charset=utf-8\r\n
Content-Length: 5096\r\n
\r\n
//  此处为5096字节的数据
```
- 内容

在具体消息内容的表现形式上，可以使用文本，也可以使用二进制。

> 文本

我们可以将数据转换为具备某种格式的字符串（如 JSON），将字符串作为消息内容发送。

比如一个RPC调用请求，方法名为divide，参数为200和100，我们可以用JSON字符串的形式来表示这个消息内容：

```json
{
    "name": "divide",
    "params": {
        "num1": 200,
        "num2": 100
    }
}
```

采用JSON这种方式，大多数编程语言都已有JSON转换的工具，实现起来相对便捷。但是我们能够看到，形成的消息数据不够精简，数据中有较为无意义的，如"、{、}、,、空白字符等，在网络传输中会造成浪费。

> 二进制

二进制方式就是将数据在内存中的一些列原始二进制位或字节直接在网络中传送，而无需转换为字符串再传送。

<img src="images/二进制传送.png" alt="二进制传送" style="zoom:50%;" />

我们能够看到，采用原始二进制传递，可以省去中间转换的环节，而且数据量也会大大减少，效率更高。

如果使用二进制的方式来传递上面举例的RPC调用请求，该如何组织数据呢？这就需要实现RPC机制的设计人员来制订一个调用双方都遵守的协议规则，不同的设计人员可能有不同的想法。

- 压缩

如果消息数据过大，为了减轻网络带宽的压力，可以考虑对消息数据进行压缩处理。

就如同我们平时对一些文件、视频等使用压缩软件进行压缩来减小大小一样，我们可以在构造好数据准备发送前，先用算法将数据进行压缩处理，然后通过网络发送到对端，对端收到数据后，先进行解压缩处理，然后得到原体积数据后再进行解析。

即使是比文本数据小的二进制数据，我们仍然可以进行压缩处理。

但是需要注意的是，压缩处理是一把双刃剑，虽然能减少数据量减轻带宽压力，但是同时额外增加了压缩和解压缩的过程，压缩和解压缩在处理的时候会有时间的消耗，会导致操作系统的负担加重。有时压缩的成本可能比减少数据量带来的收益还高，就得不偿失了。

所以是否采用压缩处理，要根据具体情况权衡利弊。

## 二进制消息协议实现

- 概述

我们现在实现一个RPC的服务接口定义，这个RPC调用可以完成除法操作。

```python
# 实现本地调用的话，很容易，定义一个函数divide
class InvalidOperation(Exception):
    """
    自定义非法操作异常
    """
    def __init__(self, message=None):
        self.message = message or 'invalid operation'

def divide(num1, num2=1):
     """
     除法
     :param num1: int
     :param num2: int, 默认值为1
     :return: float 商 或 InvalidOperation异常
     """
     if num2 == 0:
         raise InvalidOperation()
     val = num1 / num2
     return val
    
# 调用的时候，调用divde函数即可：

try:
    val = divide(200, 100)
except InvalidOperation as e:
    print(e.message)
else:
    print(val)
```

但是如果变成RPC调用的话，调用双方该以什么样的方式传递哪些消息数据呢？

我们使用二进制方式来实现消息协议。为了突出消息协议本身，我们不再进行额外压缩处理。

我们将上面的过程抽象成接口

```
float divide(1:int num1, 2:int num2=1) => InvalidOperation
```

消息协议分为两部分说明：

**调用请求消息**

```
方法名为divide
第1个调用参数为整型int，名为num1
第2个调用参数为整型int，名为num2，默认值为1
```

<img src="images/调用参数消息格式.png" alt="调用参数消息格式" style="zoom:50%;" />

**调用返回消息**

```
正常返回float类型
错误会抛出InvalidOperation异常
```

<img src="images/调用返回值消息格式.png" alt="调用返回值消息格式" style="zoom:50%;" />

- 实现

divide消息协议实现

```python

```

解析方法名实现

```python

```

测试代码

```python

```

## RPC传输

## RPC完整实现

## RPC服务器

