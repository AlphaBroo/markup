[TOC]

# 多线程

```
由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。

Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。
避免使用_threading模块，原因：1.高级别的更先进，对多线程支持更完善；2.低级别的同步原语少，threading的多；3._thread模块在主线程结束时，所有线程会被强制结束，无警告也无征程清除工作。threading模块则不会。
```

## 线程的退出

```
1.当一个线程结束计算，自然退出。
2.调用_thread.exit()，退出。
3.退出进程的方法:sys.exit()或抛出SystemExit异常
```

## threading

```python
由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2…

_thread模块不支持守护线程，当主线程退出，所有子线程全部强制退出。threading模块支持守护线程。如果设定一个线程为守护线程，表示这个线程不重要，在进程退出时，不用等待这个线程退出。若主线程退出时不用等待子线程完成，则在线程Thread.start()前，设定Thread.setDaemon(True)。若一定要等待子线程的执行完成再退出主线程，则使用默认情况或显式调用Thread.setDaemon(False)。新的子线程会继承父线程的daemon标志。整个python在所有非守护线程退出后才会结束。

# 返回当前线程的实例
threading.current_thread()
# 查看线程个数
len(threading.enumerate())
# 判断daemon的标志的值
Thread.isDaemon()
```

创建线程的方法

```
1. 创建一个Thread实例，传给它一个函数
2. 创建一个Thread实例，传给它一个可调用的类的对象
3. 从Thread派生一个子类，创建这个子类的实例
```

threading模块提供的方法

| 方法                  | 说明                                                        |
| --------------------- | ----------------------------------------------------------- |
| `start()`             | 开始线程的执行                                              |
| `run()`               | 定义线程的功能函数(一般会被子类重写)                        |
| `join(timeout=None)`  | 程序挂起，直到线程结束，如果给了timeout,则最多阻塞timeout秒 |
| `getName()`           | 返回线程的名字                                              |
| `setName(name)`       | 设置线程的名字                                              |
| `isAlive()`           | 布尔标志，表示这个线程是否还在运行中                        |
| `isDaemon()`          | 返回线程的deemon标志                                        |
| `setDaemon(daemonic)` | 把线程的daemon标志设置成daemonic                            |

简单示例：

```python
import time, threading

# 新线程执行的代码:
def loop():
    print('thread %s is running...' % threading.current_thread().name)
    n = 0
    while n < 5:
        n = n + 1
        print('thread %s >>> %s' % (threading.current_thread().name, n))
        time.sleep(1)
    print('thread %s ended.' % threading.current_thread().name)

# 主线程执行
print('thread %s is running...' % threading.current_thread().name)
t = threading.Thread(target=loop, name='LoopThread')
t.start()
t.join()
print('thread %s ended.' % threading.current_thread().name)
```

## 执行代码的封装

python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。

```python
#coding=utf-8
import threading
import time

class MyThread(threading.Thread):
    def run(self):
        for i in range(3):
            time.sleep(1)
            msg = "I'm "+self.name+' @ '+str(i) #name属性中保存的是当前线程的名字
            print(msg)


if __name__ == '__main__':
    t = MyThread()
    t.start()
```

## 线程同步

### 共享全局变量

```
多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。
```

示例：

```python
import threading
import time

g_num = 0

def work1(num):
    global g_num
    for i in range(num):
        g_num += 1
    print("----in work1, g_num is %d---"%g_num)


def work2(num):
    global g_num
    for i in range(num):
        g_num += 1
    print("----in work2, g_num is %d---"%g_num)


print("---线程创建之前g_num is %d---"%g_num)

t1 = threading.Thread(target=work1, args=(1000000,))
t1.start()

t2 = threading.Thread(target=work2, args=(1000000,))
t2.start()

while len(threading.enumerate()) != 1:
    time.sleep(1)

print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)
```

### Lock

- 互斥锁

```
当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制

线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。

互斥锁为资源引入一个状态：锁定/非锁定

某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。
```

threading模块中定义了Lock类，可以方便的处理锁定：

```
# 创建锁
mutex = threading.Lock()

# 锁定
mutex.acquire()

# 释放
mutex.release()

# 注意：
如果这个锁之前是没有上锁的，那么acquire不会堵塞
如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止
```

使用互斥锁完成2个线程对同一个全局变量各加100万次的操作

```
import threading
import time

g_num = 0

def test1(num):
    global g_num
    for i in range(num):
        mutex.acquire()  # 上锁
        g_num += 1
        mutex.release()  # 解锁

    print("---test1---g_num=%d"%g_num)

def test2(num):
    global g_num
    for i in range(num):
        mutex.acquire()  # 上锁
        g_num += 1
        mutex.release()  # 解锁

    print("---test2---g_num=%d"%g_num)

# 创建一个互斥锁,默认是未上锁的状态
mutex = threading.Lock()

# 创建2个线程，让他们各自对g_num加1000000次
p1 = threading.Thread(target=test1, args=(1000000,))
p1.start()

p2 = threading.Thread(target=test2, args=(1000000,))
p2.start()

# 等待计算完成
while len(threading.enumerate()) != 1:
    time.sleep(1)

print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)
```

- 死锁

```
锁的好处：
确保了某段关键代码只能由一个线程从头到尾完整地执行

锁的坏处：
阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了
由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁

避免死锁:
程序设计时要尽量避免（银行家算法）
添加超时时间等
```

### RLock



### Semaphore



### threadlocal

在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。

一个`ThreadLocal`变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。`ThreadLocal`解决了参数在一个线程中各个函数之间互相传递的问题。

`ThreadLocal`最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。

```python
# 在函数调用的时候，传递起来很麻烦：
def process_student(name):
    std = Student(name)
    # std是局部变量，但是每个函数都要用它，因此必须传进去：
    do_task_1(std)
    do_task_2(std)

def do_task_1(std):
    do_subtask_1(std)
    do_subtask_2(std)

def do_task_2(std):
    do_subtask_2(std)
    do_subtask_2(std)
    

# 用一个全局dict存放所有的Student对象，然后以thread自身作为key获得线程对应的Student对象
global_dict = {}

def std_thread(name):
    std = Student(name)
    # 把std放到全局变量global_dict中：  
    global_dict[threading.current_thread()] = std
    do_task_1()
    do_task_2()

def do_task_1():
    # 不传入std，而是根据当前线程查找：
    std = global_dict[threading.current_thread()]
    ...

def do_task_2():
    # 任何函数都可以查找出当前线程的std变量：
    std = global_dict[threading.current_thread()]
    ...
```

全局变量`local_school`就是一个`ThreadLocal`对象，每个`Thread`对它都可以读写`student`属性，但互不影响。你可以把`local_school`看成全局变量，但每个属性如`local_school.student`都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，`ThreadLocal`内部会处理。

可以理解为全局变量`local_school`是一个`dict`，不但可以用`local_school.student`，还可以绑定其他变量，如`local_school.teacher`等等。

```python
import threading

# 创建全局ThreadLocal对象:
local_school = threading.local()

def process_student():
    # 获取当前线程关联的student:
    std = local_school.student
    print('Hello, %s (in %s)' % (std, threading.current_thread().name))

def process_thread(name):
    # 绑定ThreadLocal的student:
    local_school.student = name
    process_student()

t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')
t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')
t1.start()
t2.start()
t1.join()
t2.join()
```

## 线程间通信

### Queue

 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。

这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。

队列分类

| 类                           | 原理     | 说明                       |
| ---------------------------- | -------- | -------------------------- |
| Queue.Queue(maxsize)         | 双向列表 | FIFO(先进先出队列)         |
| Queue.LifoQueue(maxsize)     | list     | LIFO(后进先出)             |
| Queue.PriorityQueue(maxsize) | 堆       | 优先级队列(优先度低的先出) |

常用方法

| 方法                                   | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `__init__(self, maxsize=0)`            | 初始化队列长度，maxsize为0时长度无限                         |
| `empty()`                              | 若队列为空，返回True，反之False                              |
| `full()`                               | 若队列满了，返回True，反之False                              |
| `qsize()`                              | 返回队列的大小(并不可靠)                                     |
| `get([block][,timeout])`               | 从队头获取并删除元素<br>block为true：timeout为None时候，阻塞当前线程直到队列中有可用元素；timeout为非负时候，等了timeout的时间还没有可用元素时候抛出一个Empty异常；<br>block为false：timeout为None时候，队列为空则抛出Empty异常；timeout为非负时候，等待timeout时候后没有可用元素则抛出Empty异常 |
| `get_nowait()`                         | 相当于Queue.get(False)                                       |
| ` put(item, block=True, timeout=None)` | 在队尾插入一个元素<br>block为true：timeout为None时候，阻塞当前线程直到队列中有可用位置；timeout为非负时候，等了timeout时间还没有可用位置时候抛出一个Full异常；<br>block为false：timeout为None时候，队列没有位置则抛出Full异常；timeout为非负时候，等待timeout时候后还是没有可用位置则抛出Full异常 |
| `put_nowait(item)`                     | 相当于Queue.put(item,False)                                  |
| `join()`                               | 阻塞当前线程直到队列的任务全部完成了                         |
| `task_done()`                          | 通知队列任务的完成情况，当完成时候唤醒被join阻塞的线程       |

> 样例

Demo1

```python
import threading,time,queue


q = queue.Queue()

def producer():
    n = 0
    while n < 5:
        n += 1
        q.put(n)
        print('Producer has created %s' % n)
        time.sleep(0.1)
        
def consumer():
    count = 0
    while count < 5:
        count += 1
        data = q.get()
        print('consumer has uses %s' % data)
        time.sleep(0.2)
    
if __name__ == "__main__":
    p = threading.Thread(target=producer, name='')
    c = threading.Thread(target=consumer, name='')
    p.start()
    c.start()
    p.join()
    c.join()
```

Demo2

```python
import threading,time,queue


class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    def run(self):
        print ("开启线程：" + self.name)
        process_data(self.name, self.q)
        print ("退出线程：" + self.name)

def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print ("%s processing %s" % (threadName, data))
        else:
            queueLock.release()
        time.sleep(1)
        
def main():
    global exitFlag
	exitFlag = 0
	threadList = ["Thread-1", "Thread-2", "Thread-3"]
	nameList = ["One", "Two", "Three", "Four", "Five"]
	threads = []
	threadID = 1

	# 创建新线程
	for tName in threadList:
    	thread = myThread(threadID, tName, workQueue)
    	thread.start()
    	threads.append(thread)
    	threadID += 1

	# 填充队列
	queueLock.acquire()
	for word in nameList:
    	workQueue.put(word)
	queueLock.release()

	# 等待队列清空
	while not workQueue.empty():
    	pass

	# 通知线程是时候退出
	exitFlag = 1

	# 等待所有线程完成
	for t in threads:
    	t.join()
	print ("退出主线程")

if __name__ == "__main__":
    queueLock = threading.Lock()
	workQueue = queue.Queue(10)
    mian()

************************************
开启线程：Thread-1
开启线程：Thread-2
开启线程：Thread-3
Thread-3 processing One
Thread-1 processing Two
Thread-2 processing Three
Thread-3 processing Four
Thread-1 processing Five
退出线程：Thread-3
退出线程：Thread-2
退出线程：Thread-1
退出主线程
```

## 多线程版UDP聊天器

```python
import socket
import threading


def send_msg(udp_socket):
    """获取键盘数据，并将其发送给对方"""
    while True:
        # 1. 从键盘输入数据
        msg = input("\n请输入要发送的数据:")
        # 2. 输入对方的ip地址
        dest_ip = input("\n请输入对方的ip地址:")
        # 3. 输入对方的port
        dest_port = int(input("\n请输入对方的port:"))
        # 4. 发送数据
        udp_socket.sendto(msg.encode("utf-8"), (dest_ip, dest_port))


def recv_msg(udp_socket):
    """接收数据并显示"""
    while True:
        # 1. 接收数据
        recv_msg = udp_socket.recvfrom(1024)
        # 2. 解码
        recv_ip = recv_msg[1]
        recv_msg = recv_msg[0].decode("utf-8")
        # 3. 显示接收到的数据
        print(">>>%s:%s" % (str(recv_ip), recv_msg))


def main():
    # 1. 创建套接字
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # 2. 绑定本地信息
    udp_socket.bind(("", 7890))

    # 3. 创建一个子线程用来接收数据
    t = threading.Thread(target=recv_msg, args=(udp_socket,))
    t.start()
    # 4. 让主线程用来检测键盘数据并且发送
    send_msg(udp_socket)

if __name__ == "__main__":
    main()

```

037163795566

02155赵