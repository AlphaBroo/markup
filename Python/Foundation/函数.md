# 定义与调用

```
# 创建函数一般格式：
# def 函数名（参数列表）:
    # 函数体
    
# 调用函数一般格式：
# 函数名(参数列表)

# 函数 
# 可重复使用的，用来实现单一，或相关联功能的代码段
# 同一个程序中函数名不能相同，变量名不能与函数名相同 
```

# 函数类型

```
# 无参数无返回
# def 函数名():
    # 语句

# 无参数有返回
# def 函数名():
    # 语句
    # return 需要返回的数值
    
# 有参数无返回
# def 函数名(形参列表):
    # 语句

# 有参数有返回
# def 函数名(形参列表):
    # 语句
    # return 需要返回的数值
```

# 返回值

```
'''
return [表达式]
'''
#无论循环嵌套多少层，只要遇到一个return返回表达式后，就退出整个函数函数。没有return语句或不带参数值的return语句返回None
# return后面可以是元组，列表、字典等，只要是能够存储多个数据的类型，就可以一次性返回多个数据
 # def function():
          # return [1, 2, 3]
          # return (1, 2, 3)
          # return {"num1": 1, "num2": 2, "num3": 3}
# 如果return后面有多个数据，那么默认是元组
# def s(a,b,c):
    # return a,b,c
  
# print(s('a',2,3))

"""
返回的数据拆包
"""
# 拆包时要注意，需要拆的数据的个数要与变量的个数相同，否则程序会异常
# 拆包适用于元组、列表、字典(获得key)等
# def get_my_info():
    # high = 178
    # weight = 100
    # age = 18
    # return high, weight, age
# my_high, my_weight, my_age = get_my_info()
# print(my_high)
# print(my_weight)
# print(my_age)
```

# 函数参数

```
"""
形参与实参
"""
# 定义时小括号中的参数，用来接收参数用的，称为 “形参”
# 调用时小括号中的参数，用来传递给函数用的，称为 “实参”


"""
参数的传递
"""
# 在python中，一切皆对象，变量中存放的是对象的引用
# 在python中，参数传递的是值(实参的id值)传递，对于绝大多数情况，函数内部直接修改形参的值是不会影响实参


"""
参数类型
"""
# 必需参数(位置参数)
# 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。
# 默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的

# 关键字参数
# 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。

# 默认参数(缺省参数)
# 调用函数时，如果缺省传递参数，则会使用默认参数。
# 注意：默认参数位于最后面

# 不定长参数
# 能处理比当初声明时更多的参数
# 加*的变量args会存放所有未命名的变量参数(依位置传参)，args为元组
# 加**的变量kwargs会存放命名参数(依key传参),即形如key=value的参数,kwargs为字典.
# def functionname([formal_args,] *args, **kwargs):
   # """函数_文档字符串"""
   # function_suite
   # return [expression]
```

# 递归函数

```
# 函数在内部调用自己本身
# 递归必须有结束条件，递归向结束条件发展

# 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰,却可以避免递归的栈溢出

# 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出

# 递归时放止栈溢出(Stack overflow)可以，
# 方法一：人为设置递归深度
import sys
sys.setrecursionlimit(1000000) #括号中的值为递归深度
# 方法二：尾递归优化
# 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

# 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况

# 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。

# 计算输入数字的阶乘
# 未优化
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
# 尾递归优化
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)

```

# 内置函数

内置函数是python内置对象类型之一，不需要额外导入在任何模块即可使用，这些内置对象都封装在内置模块`__builtins__`之中，用C语言实现并进行了大量优化

> 查看所有内置函数和内置对象

```
dir(__builtins__)
```

> 帮助

```
help(math)
```

> 常用内置函数

| 函数                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| abs(x)                       | 返回数字x的绝对值或复数x的模                                 |
| all(iterable)                | 若可迭代对象中所有元素bool(x)等于True，则返回True,若iteable为空，也返回True |
| any(iterable)                | 若可迭代对象中存在元素bool(x)等于True，则返回True,若iteable为空，返回False |
| ascii(obj)                   | 把对象转换为ASCII码表示形式，必要式使用转义符来表示特定的字符 |
| bin(x)                       | 把x转换为二进制串表示形式                                    |
| bool(x)                      | 返回与x等价的布尔值True或False                               |
| bytes(x)                     | 生成字节串，或吧指定对象x转换为字节串表示形式                |
| callable(obj)                | 测试对象obj是否可调用。类和函数是可调用的，包含`__call__()`方法的类的对象也是可调用的 |
| compile()                    | 用于把python代码编译成可被exec()或eval()函数执行的代码对象   |
| complex(real, [imag])        | 返回复数                                                     |
| chr(x)                       | 返回Unicode编码为x的字符                                     |
| delattr(obj, name)           | 删除属性，等价于del obj.name                                 |
| dir(obj)                     | 返回指定的对象或模块obj的成员列表，若不带参数则返回当前作用域内所有标识符 |
| divmod(x, y)                 | 返回包含整商和余数的元祖((x-x%y)/y, x%y)                     |
| enumerate(iterable[,start])  | 返回包含元素形式为(start, iterable[0]), (start+1, iterale[1]), (start+2, iterable[2]),…的迭代器对象，start表示索引的起始值 |
| eval(s[, globals[, locals]]) | 计算并返回字符串s中表达式的值                                |
| exec(x)                      | 执行代码或代码对象x                                          |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |
|                              |                                                              |

