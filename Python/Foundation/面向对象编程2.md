[TOC]

# 魔法属性

魔法方法被设计用于重载python的操作符或内置方法。魔术方法可以通过`__`语法定义，从而避免程序员在没有意向使用重载时碰巧定义了同名方法。魔术方法使内置类（包括诸如整型和字符串等基本类型）提供的约定与自定义类提供的约定保持一致。

当口头提到该方法时，`__init__`发音dunder-init

每个魔法方法都有特定的目的，当特定语法出现时，它作为执行的钩子(在特定事件发生时，能够响应事件而调用的代码或函数)

## 执行

对于`__init__`方法，在代码中并没有直接调用，仅仅是python的解释器知道在对象初始化时调用该方法

所有的魔法方法都是需要特定的函数名称与方法签名(有时签名是一个变量)，然后该方法就会在特定的情况下被解释器调用

## 常见方法

### 创建与销毁

该类方法在类的实例创建或销毁时执行

```python
__init__()
# 在创建实例后会立即执行对象的__init__方法,此方法为创建后的对象提供初始化数据。
# 初始化函数，并没有创建新对象(__new__)，无返回值，不能return，未创建时，python默认自动创建,
# 默认第一个参数是self,然后可以接受任意数量的必要和可选位置参数，以及任意数量的关键字参数

__new__()
# 在__init__之前执行，用于创建类的实例
# 必须有返回值，为类的实例对象，未创建时，Python默认调用父类自动创建
# 只有在通过__new__方法返回当前类的实例时才执行__init__方法，若返回的不是当前类的实例，则不会调用__init__方法
# __new__方法是静态的，无需显式装饰，第一个参数是cls，代表要实例化的类，在实例化时由Python解释器自动提供
# 在大多情况下，方法的其他参数会被完整复制到__init__方法中。
# 实际使用，无需定义此方法，内置实现已够用。
# 在重写new方法的时候，几乎都需要首先在实现本类逻辑之前引用父类的实现，可以return父类__new__出来的实例，或直接是object的__new__出来的实例
def __new__(cls, *args, **kwargs):
    # 可以super()或者父类名或者object
    return object.__new__(cls)

__del__()
# 载对象被销毁时被调用
# 只有一个参数self，无返回值，通常由垃圾回收器触发，无法引起任何有意义的异常
# 若无__del__,当使用类创建一个对象后，待程序执行完成后，对象默认会自动销毁。当对象销毁后，会触发其类的__del__方法
# 若有__del__，对象引用结束，程序未结束时，python会自动调用__del__方法
# 当变量保存了多次对象引用后，对象计数器增加，只有使用del(),把对象全部销毁，计数器为0时，才能触发__del__方法
```

### 类型转换

在python中存在多个用于将复杂对象转换为简单对象或常用数据类型的魔术方法，如str,int,bool等。对于复杂对象来说知道自身使用简单类型的等价表示十分有用

```python
__str__,__unicode__,__bytes__
# __str__接受一个位置参数self，并在对象被传递给str的构造函数时被调用，返回一个字符串
# 当通过str的参数遇到格式化字符串%s时，也会被调用，在python2中会首先尝试__unicode__
# 未创建时，默认情况下，打印对象是输出对象的内存地址
# 若重写了__str__魔法方法，会打印这个方法返回的字符串，作为这个对象的描述信息,若直接输出，输出对象的内存地址
# __unicode__在对象传递给unicode的构造函数时被调用，返回合适的类型，适用python2
# __bytes__在对象传递给bytes的构造函数时被调用，返回合适的类型，适用python3
# 在python2中，字符串使用ASCII字符串，存在Unicode编码的字符串
# 在python3中，字符串使用Unicode字符串，引入了bytes类型
class MyObject(object):
    def __str__(self):
        return 'hi'

str(MyOject()) # 输出'hi'
'This is %s' % MyObject()

class Which(object):
    def __str__(self):
        return 'string'
    def __unicode__(self):
        return u'unicode'
    
u'The %s was used' % Which()
'This %s was used' % Which()


__bool__,__nonzero__
# 对象需要界定True或False，无论时通过表达式转换为布尔类型，还是在某些情况下需要该对象布尔类型的等价形式(if语句)
# 接受一个位置参数并返回True或False
# 通常不需显式定义一个__bool__方法，若无定义__bool__，但定义了__len__,就将适用后者，从而导致重复
# 在python3中，该类型由__bool__处理
# 在python2中，该类型由__nonzero__处理

__int__,__float__,__complex__
# 将复杂对象转为基本类型的数字。如果一个对象定义了一个返回INT类型的__init__方法，那么该对象被传递给int的构造函数时，int方法会被调用。如果对象定义了__float__,__complex__方法，那么这些方法会在各自传递给float或complex的构造函数时被调用
```

### 比较

对象在进行相等性测试(==或!=)或不等性测试(<,<=,>,>=)时进行比较，这些操作符与python中的魔法方法一一对应

#### 二元相等性

下面的方法支持使用==或!=进行相等性测试

```python
__eq__
# 在两个对象使用==操作符进行比较时被调用。必须接受两个位置参数(self,other),是需要比较的两个对象
# 一般情况下，首先检测左边对象的__eq__方法是否存在，若存在则调用(不再返回NotImplemented).否则，使用右边对象中定义的__eq__方法(参数位置对调)
# 当被比较的两个对象中一个对象是另外一个对象的直接子类，将使用子类的__eq__方法
class MyClass(object):
    def __eq__(self, other):
        print(self, other)
        return self is other

c1 = MyClass()
c2 = MyClass()
c1 == c2
c2 == c1
c1 == c1

class MySubclass(MyClass):
    def __eq__(self, other):
        print(self ,other)
      	return False
    
MySubclass() == MyClass()
MyClass() == MySubclass()  


__ne__
# 在使用!=操作符时使用，与__eq__方法的功能相反
# 通常无须定义__ne__方法，只需针对__eq__方法的返回值取反即可。若时没有定义__ne__方法，则python会调用__eq__方法，并对结果取反
```

#### 相对比较

以下方法处理比较操作符来测试相对值(>)

```python
__lt__,__le__,__gt__,__ge__
# 分别与<,<=,>,>=操作符相匹配。上述方法都接受两个参数(self,other),并在相对比较时根据运算符结果返回True或False
# 通常无须全部定义这四个方法，python解释器会认为__lt__是__ge__取反，__gt__是__le__取反；同理，解释器会认为__le__是由__lt__和__eq__分离得来，__ge__是由__gt__和__eq__分离得来；实际上只需定义__eq__和__lt__(或__gt__)，则所有6个比较操作符就能按照预期正常生效
# 注意：这些方法内置了用于排序对象的sorted函数。因此，若有一个列表中的所有对象都定义了这些方法，将对象传递到sorted就会基于比较方法的结果自动返回一个升序排序后的列表

__cmp__
# 为对象定义相对比较的旧有(不推荐)方式，只有之前描述的方法未被定义时，才检查该方法是否被定义
# 该方法接受两个位置参数(self,other),若self比other小，那么返回一个负数；若是self比other大，返回一个正整数，若是相等，则返回0
# python2中已淘汰，python3中不可用
```

#### 操作符重载

提供了一种重载标准python操作符的机制

- 二元操作符

```
一系列魔法方法可用于重载python中的多种二元操作符，如+和-等。实际上对于每一个操作符，python都提供了3种魔法方法，每种方法都接受两个位置参数(self,other)
1. 普通方法(vanilla method)
表达式x+y与x.__add__(y)匹配，这类方法仅仅返回结果
2. 取反方法(reverse method)
只有在第一个操作对象不提供传统方法并且操作对象类型不同(返回NotImplemented)时才调用取反(操作符两边顺序交换)。
这两类方法的拼写机制相同，只是取反方法在方法名称的开头加上了r，因此，对于表达式x+y,若x没有定义__add__方法，则调用y.__radd__(x)
3. 即席方法(in-place method)
在操作符即席修改第一个变量时被调用(如+=，-=)。即席方法与第一类方法的拼写机制相同，只是这类方法仅仅是在正常方法开头加了i。因此表达式x+=y将会调用x.__iadd__(x)
通常，即席方法仅仅即席修改self并返回它。但这并不是严格的需求。值得注意的是，仅在直接方法没有清晰匹配的情况下，才需要定义一个即席方法。若未定义即席方法，则会调用直接方法将值赋值给操作符左边的对象并返回
```
操作符重载的魔法方法

| 操作符 | 方法           | 取反            | 即席            |
| ------ | -------------- | --------------- | --------------- |
| +      | `__add__`      | `__radd__`      | `__iadd__`      |
| -      | `__sub__`      | `__rsub__`      | `__isub__`      |
| *      | `__mul__`      | `__rmul__`      | `__imul__`      |
| /      | `__truediv__`  | `__rtruediv__`  | `__itruediv__`  |
| //     | `__floordiv__` | `__rfloordiv__` | `__ifloordiv__` |
| %      | `__mod__`      | `__rmod__`      | `__imod__`      |
| **     | `__pow__`      | `__rpow__`      | `__ipow__`      |
| &      | `__and__`      | `__rand__`      | `__iand__`      |
| \|     | `__or__`       | `__ror__`       | `__ior__`       |
| ^      | `__xor__`      | `__rxor__`      | `__ixor__`      |
| `<<`   | `__lshift__`   | `__rlshift__`   | `__ilshift__`   |
| `>>`   | `__rshift__`   | `__rrshift__`   | `__irshift__`   |

除法

```python
最初，在python中的两个int型数据进行除法运算。返回值类型为int，而不是float。基本原理是两个数进行除法运算然后向下取整。若是希望得到float数据类型的结果，则至少需要其中一个值的类型是float
python3中修改了该特征，对两个Int类型数据做除法返回float类型的数据，即使结果是整数也是如此。
在python2的后续版本中，特殊模块__future__用于倒入未来特征，在2.6和2.7中，通过加入from __future__ import division来可选python3特征

python3中使用__truediv__(同类方法)，当引入future时，python2也执行__truediv__(同类方法)
通常，在python2中执行的代码最终如何处理除法并不可知，需要同时定义__truediv__和__div__
或许使用__truediv__且将__div__作为别名
# 如下时可行的
class MyClass(object):
    def __truediv__(self, other):
        [...]
    __div__ = __truediv__  
```

- 一元操作符

+,-,~

+和-即是一元操作符也是二元操作符。解释器可以根据表达式确定操作符被用于一元还是二元
只接受一个位置参数(self)，执行操作并返回结果。三个方法的名称分别为`__pos__(+)`,`__neg__(-)`,`__invert__(~)`

表达式~x，就是调用`x.__invert__()`

```python
# 仿string类
class ReversibleString(object):
    def __init__(self, s):
        self.s = s
        
    def __invert__(self):
        return self.s[::-1]
    
    def __str__(self):
        return self.s
    
rs = ReversibleString('hi')
print(~rs)  # rs变量并未被赋值，输出是str对象

# 另一种
class ReversibleString(object):
    def __init__(self, s):
        self.s = s
        
    def __invert__(self):
        return type(self)(self.s[::-1])
    
    def __repr__(self):
        return 'ReversibleString: %s' % self.s
    
    def __str__(self):
        return self.s
    
rs = ReversibleString('hi')
print(~rs)  # 输出对象是ReversibleString，可以被多次逆序
print(~rs)  # 调用了rs对象的__invert__方法，然后对表达式结果再次调用__invert__方法
```

#### 重载常见方法

python包含了很多内置方法，被广泛使用并将对象作为操作符。因此，python提供了对象传递到这些方法时被调用的魔法方法

```python
__len__
# 确定一个条目的长度,接受位置参数(self)并返回一个整型值
# 通常还被用于确定对象被类型转换为bool或用于if语句时，其值是True还是False，除非对象定义了__bool__(python2中__mozero__)
class Timespan(object):
    def __init__(self, hours=0, minutes=0, seconds=0):
		self.hours = hours
		self.minutes = minutes
        self.seconds = seconds
        
    def __len__(self):
        return (self.hours * 3600) + (self.minutes * 60) + self.seconds
    
ts = Timespan(hours=2, minutes=30, seconds=1)
len(ts)
bool(ts)
bool(Timespan(hours=0, minutes=0, seconds=0))

__repr__
# 用于确定对象载python交互式终端中的显示方式，接受一个位置参数(self)
# 未创建时，默认情况下，打印对象调用__str__
# 若重写了__repr__魔法方法，会打印这个方法返回的字符串，作为这个对象的描述信息
# 若直接输出，也输出对象的描述信息
# 与str区别取决于读取内容的不同，repr给程序员读，str给普通用户
class Timespan(object):
    def __init__(self, hours=0, minutes=0, seconds=0):
		self.hours = hours
		self.minutes = minutes
        self.seconds = seconds
        
    def __repr__(self):
        return 'Timespan(hours=%d, minutes=%d, seconds=%d)'%(self.hours, self.minutes, self.seconds)
# 在终端上
>>> Timespan()

__hash__
# 通过数字化表达式唯一标识对象
# 当一个对象传递给散列函数时，调用其__hash__方法。接受一个位置参数(self)，返回一个整型值，可以负数
# 对象类提供了__hash__函数，通常返回该对象的id，对象的id值是与实现方式具体相关的，在CPython中，该值是其内存地址
# 若是定义了__eq__方法，则__hash__方法会隐式地被赋值为None。这样做是由于通常哈希值的目的很模糊。取决于对象的使用方式，每一个对象拥有哈希值且保持唯一是最佳实践，并且相等的对象其哈希值也应该相等
# 若一个类能够理解相等且可哈希化时，其必须显式定义一个__hash__方法
# 最常用处于字典的键值与set对象。仅有可哈希的对象可以作为字典的键值和在set对象中存在，为了可以确定查找

__format__
# 根据python的格式化规范来格式化不同种类的对象
# 在对象被传递到format时调用，接受两个位置参数，第一个为self，第二个是格式化规范的字符串
# 在python3中，str.format方法倾向使用__format__方法替换%操作来处理字符串内的占位符
from datetime import datetime

class MyDate(datetime):
    def __format__(self, spec_str):
		if not spec_str:
            spc_str = '%Y-%m-%d %H:%M:%S'
        return self.strtime(spec_str)
    
md = MyDate(2012, 4, 21, 11)
'{0}'.format(md)

__instancecheck__,__subclasscheck__
# python2.6引入，可以伪装类身份，极少需要自定义
# 接受两个参数，第一个是self，第二个是用于比较的类，允许类决定哪个对象可能会伪装成其实例或子类
# 内置的isinstance方法检查一个对象是否是某个类的实例，issubclass检查一个类是否继承于另一个类，若是则都返回True，若不是则返回False


__abs__,__round__
# 分别用于返回绝对值于取整后的值，很少需要自定义
# 接受一个位置参数self,返回一个数字类型的值
```

#### 集合

很多对象都是其他不同种类对象的集合。最复杂的类功能上是来自属性的集合(以某种有意义的方式排列)与对象中定义的方法集合

python通过几种方式来理解一个对象与另外一个对象是否为"成员关系"。

```
对于列表和字典，通过needle in haystack检查一个对象是否是一个集合的成员
字典由键组成，且可以通过haystack[key]基于键进行查找。
大多数对象拥有属性，这些属性在初始化时设置或通过其他方法设置，可以使用点操作符访问(haystack.attr_name)
```

python提供了与所有这些对象交互的魔法方法

```python
__contains__
# 在对表达式求值(needle in saystack)被调用
# 接受两个位置参数(self, needle),若needle在集合中，返回True，否则返回False
# 该方法并不能严格确保某一对象在一个集合中，虽然常用语此情况
class DataRange(object):
    """表示一段时间区间"""
    def __init__(self, start, end):
        self.start = start
        self.end = end
    def __contains__(self, needle):
        return self.start <= neddle <= self.end

dr = DataRange(date(2015, 1, 1), date(2015, 12, 31))
print(date(2015, 4, 21) in dr)
print(date(2012, 4, 21) in dr)

__getitem__,__setitem__,__delitem__
# 此类方法用于对集合(如字典)，索引或部分集合(如列表)进行键查找，基本表达式式haystack[key]
# __getitem__方法接受两个参数，self,key。该方法在集合能找到元素时返回对应值，否则引发对应的异常，引发一场取决于具体情况，但通常都是IndexError,keyError,TypeError
# __setitem__方法接受三个位置参数，self,key,value。用于设置集合元素的值。并非所有支持元素查找的对象也同时支持元素修改。若需要，可以在定义__getitem__下不定义__setitem__
# __delitem__方法在使用del关键字(del haystack[key])时被调用。

__getattr__,__setattr__
# python类用作集合的另一种方式时作为属性与对象的集合。当date对象包含year、month、day时，这些都是属性
# 无论是通过点(obj.attr_name)还是getattr方法(getattr(obj, 'attr_name)),__getattr__方法都会在试图获取一个对象的属性时被调用。但是解释器先进行标准的属性查找，若是发现则返回，若没有匹配属性(AttributeError),才会调用__getattr__方法。接受两个位置参数(self,key)，返回合适的值，或是引发AttributeError
# __setattr__方法用在赋值一个对象时被调用，无论是通过点操作符还是setattr方法。与__getattr__不同的是，该方法一直会被调用(否则无存在意义)，因此，若希望使用传统实现，应该调用基类方法

__getattribute__
# 只有在无法找到属性时才被调用，引起这是在常规情况下希望的行为(否则会易陷入无限循环的大坑)。然而，与__getattr不同，__getatrribute__会被无条件调用

逻辑顺序时首先调用__getattribute__,在正常情况下负责执行系统的属性查找。若类定义了__getattribute__，其变为负责调用基类的实现。如果(且只有在这种情况下)__getattribute__引发AttributeError异常，调用__getattr__方法
```

### 其他

```
# __dict__:类的属性(一个字典，由类的数据属性组成)，对象的属性
# __doc__:类的文档字符串，若无定义为None
# __name__:类的名字
# __module__:类定义所在的模块名称，交互模式其值为__main__
# __class__:当前操作的对象所在的类的名称，与内置type()一致
# __base__: 返回包含该类的所有基类的元组
# __subclasses__()：返回该类的所有子类

# __init__：初始化方法，通过类创建对象时，自动触发执行
# __del__:当对象在内存中被释放时，自动触发执行。
#  __str__:那么在打印对象时，默认输出该方法的返回值，默认是类对象
# __call__：对象后面加括号，触发执行
# __getitem__：用于索引操作获取数据，如字典
# __setitem__：用于索引操作设置数据，如字典
# __delitem__：用于索引操作删除数据，如字典
# __getslice__：分片操作获取数据，如：列表
# __setslice__：分片操作设置数据，如：列表
# __delslice__：分片操作删除数据，如：列表

# __iter__和__next__实现迭代协议
# __enter__和__exit__实现上下文管理器
```

**详解**

```python
__dict__()
# 存储类的属性(一个字典，由类的数据属性组成)，对象的属性
# 当类自定义__getattr__，getattribute__或定义特殊属性__slots__，就会更改存储内容


__iter__()
# 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。
# 以斐波那契数列为例，写一个Fib类，可以作用于for循环：
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
# 把Fib实例作用于for循环：
for n in Fib():
    print(n)
     
     
# __getitem__()
正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错
要避免这个错误，除了可以加上一个属性外，Python还有另一个机制，那就是写一个__getattr__()方法，当调用不存在的属性时，动态调用__getattr__()方法返回一个属性。

# 示例
很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：
http://api.server/user/friends
http://api.server/user/timeline/list
如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。
利用完全动态的__getattr__，我们可以写出一个链式调用：
class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__
# 调用(无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！)
>>> Chain().status.user.timeline.list
'/status/user/timeline/list'


# __call__()
一个对象实例不仅可以instance.method()调用，还可以直接在实例本身上调用instance()
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
```

# 使用枚举类

```
# Python提供了Enum类实现了：枚举类型定义一个class类型，每个常量都是class的一个唯一实例

from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

# 使用Month.Jan来引用一个常量，或者枚举它的所有成员
for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value)
value属性则是自动赋给成员的int常量，默认从1开始计数。
```

# 元类

在python中，几乎所有一切都是对象，包括函数和类。函数和类都可以作为参数提供、以类实例的成员形式存在，且可以完成其他对象所能完成的工作。作为对象的类本身也是另一种类的实例，用于创建类。负责生成其他类的类就是元类(Metaclass)。Meta是一个Greek前缀，意味着`post-`或`after`，随着时间发展，演化为对自身某种程度的引用

## 类与对象

类与类的实例之间的关系有两重意思，首先，类定义了其实例的属性和行为；其次，类可以作为创建实例的工厂。当实例化所编写的类时，类作为实例属性和行为的定义，并完成实例的生成。定义类时，仅仅是使用一个特殊的替代语法代替不同的实例化，即实例化type类，type是python内置类，该类是其他类对象的默认类

> 直接使用type

通过直接使用type而非使用关键字Class创建类。从语法上讲，这种方式很差，但有助于理解背后的机制.

一组简单的类

```python
# python解释器执行到此处，实际执行的是调用type的构造函数
class Animal(object):
    """A class representing an arbitrary animal"""
    def __init__(self, name):
        self.name = name
        
    def eat(self):
        pass
    
    def go_to_vet(self):
        pass
    
    
class Cat(Animal):
    def move(self):
        pass 
    
    def purr(self):
        pass
```
type构造函数接受3个位置参数:name, bases,attrs。其中name参数(字符串)仅仅是类的名称。bases参数是该类的基类的元组。python支持多重继承，这也是称为元组的理由。若只继承单个类，只需发送只包含一个对象的元组。attrs参数是类中所有属性的字典

- 创建类

```python
# 基本等价于class Animal，init,eat,go_to_vet方法并没有附加到位于命名空间下的类
def init(self, name):
    self.name = name
    
def eat(self):
    pass
    
def go_to_vet(self):
    pass

Animal = type('Animal', (object,), {
    '__doc__': 'A class representing an arbitrary animal',
    '__init__': init,
    'eat': eat,
    'go_to_vet': go_to_vet,
})
```

type的调用，第一个参数只是一个字符串Animal。发送该字符串，将其作为类名，但也讲type调用的结果赋给变量Animal。Class关键字可以完成如上操作。由于直接调用type，则必须讲结果赋值给变量，就像在为其他类的新实例所做的一样

第二个参数是包含一个成员的元组，表示Animal类继承自object，与之前的类一样，需要在元组尾部加逗号，以python解释器将其视为元组。括号在python中有其他用处，因此，对于只包含一个元素的元组需要在结尾处加括号

第三个参数是一个字典，定义了类的属性，等价于class代码块内缩进的代码部分。首先定义了映射到原始类中函数的函数，然后讲这些函数传入attrs字典。字典的键用于确定类中属性的名称。

- 创建子类

```python
def meow(self):
    return None

def purr(self):
    return None

Cat = type('Cat', (Animal,), {
    'meow': meow,
    'purr': purr,
})
```

继承的是Animal对象而不是object对象。传递的是Animal类本身。另外，type的第二个参数仍然是只包含一个元素的元组，无需传递`(Animal, object)`。实际上object作为Animal的基类已经融入Animal类。只有在存在多重继承的情况下才需要传递包含多个元素的元组

> type链

```python
louisoix = Cat(name='Louisoix)
```

louisoix是一个对象，也是Cat的实例，Cat类也是一个对象，同时也是type的实例，type是(继承)链的顶端

```python
type(louisoix)
type(Cat)
type(type)
```

type类是基类，位于链的顶部，因此`type(type)`返回其自身

> type角色

type是python中的主要元类，默认情况下，使用class关键字创建的普通类都是使用type作为其元类

通俗来讲，可以为类(Cat)和其实例(louisoix)引用type作为其元类

除此之外，type也是其他元类的基类。可以通过object作为所有类的基类进行类比。正如object是类继承链中的最高级，type也是元类层级的最高级

## 编写元类

从语法角度，编写元类只需声明一个继承自type的类(使用class关键字)。对象模型的精妙之处就在于此。类只是对象，元类也只是类。元类的行为继承自type。因此，任何的子类都可以作为元类

不要声明或使用任何不是直接继承自type的元类。会破坏python的多重继承机制。python的继承模型要求任何类都只能有一个元类。只有一个元类是另一个元类的直接子类(此情况下实际最终使用的是子类)时，才能接受一个类继承自使用不同子类的两个类。如果尝试实现一个不继承type类的元类，同时继承任何使用该元类的类与其他使用type作为元类的类，都会破坏多重继承。

> `__new__`

自定义元类必须定义的`__new__`，该方法实际上用于处理类的创建，且必须返回一个新类

`__new__`方法是一个类方法(并补需要显式定义)。元类中的`__new__`的大多数自定义实现都应该确保其调用基类实现，并在此代码之后完成自定义代码

在自定义元类中发送到`__new__`方法的参数必须与发送到type的`__new__`方法的参数保持一致，必须有4个位置参数

```
参数1:元类自身，伪装成一个参数的方式与绑定方法类似，按惯例，cls
参数2:string类型的类名称(name)
参数3:类继承基类的元组(bases)
参数4:包含属性的字典(attrs)
```

> `__init__`

在普通类中，通常都不会定义`__new__`方法，而是定义`__init__`方法，这是由于object提供的`__new__`实现基本足够，但是也是有必要的。重载`__new__`方法(即使直接继承object)需要调用基类方法并小心返回结果(新实例)。相反，重载`__init__`方法非常容易且相对没有风险。对象的`__init__`实现是空操作，且该方法不返回任何值

编写自定义元类时，行为则发生变化。自定义元类通常会重载`__new__`方法，但通常不会实现`__init__`方法。重载`__init__`方法时，要记住必须总是调用基类的实现。实际上，type的`__new__`实现会提供要用到的对象并返回新的实例

> 示例

仅仅展示所有前面提到功能的自定义元类

```python
class Meta(type):
    """A custom metaclass that adds no actual functionality."""
    def __(cls, name, bases, attrs):
        return super(Meta, cls).__new__(cls, name, bases, attrs)
    
# 直接调用Meta元类创建使用Meta元类的类，类似于之前直接调用type
C = Meta('C', (object,), {})
# 该类的实例不是type的实例
type(C)  # Meta
# 与正常类不同
class N(object):
    pass

type(N)  # type
```

> 元类继承

元类可以继承，故C的子类是Meta的实例，不是type的直接实例

```python
class D(C):
	pass
type(D)  # Meta
```

D是Meta的实例，并不是由于D显式生命了元类，或是调用了Meta创建了它，而是由于它的基类是Meta的实例，因此D也是Meta的实例

```
元类type ---> 元类Meta(type的子类)---> 类C(Meta对象的实例的子类)---> 类D(C的子类)
```

注意：在多数情况下类只有一个元类。即使在多继承的情况下，也是如此。若一个类的多个子类有不同的元类，python解释器会通过检查元类的起源来解决该冲突，若其元类关系为直接继承，则最终使用子类

```python
class Z(C, N):
	pass
type(Z)  # Meta
```

python解释器被告知创建类Z，Z同时是C和N的子类，等同于`type('Z', (C,N),{})`。首先，Python解释器检查C，并发现C是Meta的实例。然后检查N，发现N是type的实例。这是潜在冲突，这两个基类却不同的元类。然而python解释器同时发现Meta是type的直接子类，因此得知其可以安全地使用Meta。

```
元类type ---> 元类Meta(type的子类)---> 类C(Meta对象的实例的子类)---> 类Z(C和N的子类)
元类type ---> 类N(type对象的实例的子类)---> 类Z(C和N的子类)
```

若两个元类中的一个并不是另一个的直接子类，则存在一个冲突，而python解释器并不知道该如何解决，因此会拒绝尝试执行

## 使用元类

虽然允许直接实例化元类(type),但并不是最佳方式。python中的class提供了在不使用type作为元类的情况下，生命元类的机制。然而，根据python版本的不同，定义所使用元类的语法也不同

> python3

元类与基类(若存在)在一起声明。语法类似于在函数声明或调用中的关键字参数，而关键子参数为metaclass

```python
# 与直接调用Meta创建列完成任务相同，但是推荐
class C([object,]metaclass=Meta):
	pass
```

显式或省略直接继承object，均可，python3向后兼容，所有的类都是新式类

> python2

python2的原发与python不同，互不支持

声明元类实际上是将`__metaclass__`属性赋给类。

```python
# 元类在类中赋值，python解释器在调用类关键子时搜索元类赋值代码并用Meta而不是type来创建新类
class C(object):
	__metaclass__ = Meta
```

> 跨版本

python3不向python2兼容，需要考虑将同样代码运行在不同版本而得到相同结果的策略

正在使用python2，未来可能迁移至python3，则希望编写跨版本兼容的代码，否则直接pthon3

其中方法之一：是使用`six`工具，six工具为声明元类提供了两种方法：通过创建一个替身类并将其用作直接基类，或者使用装饰器添加元类

```python
# 替身类方法	
import six

class C(six.with_metaclass(Meta)):
    pass
```

six.with_metaclass创建一个直接继承object的虚类，并使用Meta作为其元类，该类并不完成任何工作。通过将该类用作C的基类，并基于元类与类继承交互的方式，无论在任何python版本下，C现在都是Meta的实例

根据使用元类的不同，有事上述解决方案可能不起作用。因为six.with_metaclass实际上是实例化一个类，某些元类kennel会完成一些任务，而完成的任可能与抽象基类不兼容

```python
# 装饰器法
import six

@six.add_metaclass(Meta)
class C(object):
    pass
```

此时在python2和python3中的实现结果变为相同，类C使用class关键字与Meta元类(不是使用type元类)创建。装饰器在不实例化抽象类的情况下完成了这项工作

## 使用时机

大多数代码使用传统的类与对象的结构都没问题，并不需要使用元类，同时，使用元类额外增加了一层复杂性。当使用元类时，能够让代码更加简单，就是更好时机

- 说明性类声明

在类声明与类结构之间创建描述，尤其是在创建供其他开发人员使用的API时，可以使用自定义元类

```python
from django.db import models

class Book(models.Model):
    author = models.CharField(max_length=100)
    title = models.CharFiled(max_length=250)
    isbn = models.CharField(max_length=20)
    publication_data = models.DateFiled()
    pages = models.PositiveIntegerField()
```

Book实例的author,title,isbn属性，将会得到字符串。publication_data属性为datetime.date对象，pages为int对象.如未将属性提供给模型，则返回结果未None

Django模型使用随其一同发布的元类ModelBase。使用django时，它被隐藏起来，因为`django.db.models.Model`使用了ModelBase元类。因此，子类可以直接获取它

ModelBase完成了很多工作，但它的主要工作还是在Django的模型类的声明方式与它们对象的组织方式之间进行转换。对于Django来说，有一个非常简单直接的模型声明方式，一个模型代表一个表，模型中的属性对应于表中的列。Django生态系统中的实例表示表中的行，当访问实例中的一个域时，真正想要的是该行的值

本质上，在此使用元类是可取的，因为它使声明Book类与访问Book实例的数据变得整洁，即使这些属性不匹配，也可使用凭直觉获取API

说明

```
ModelBase实现过程：
	首先，创建模型类时，该类的属性被传递给字典中的元类的__new__方法，该字典通常被命名为attrs，上例中，该字典包含author，title等作为键。这些键对应的值时Field对象(所有这些类都是django.db.models.Field的子类)
	ModelBase元类有一个用于迭代attrs字典以寻找Field子类的__new__方法。该方法发现的任何attrs字典的域都会弹出到另一个位置--另一个名为fields的字典(实际上在该类的另一个对象_meta中)，除了了解时机field类的位置之外，其他实现细节并不特别重要，隐藏在内部Django代码，仅在需要时提取。
	创建实例时，对应于域的属性被实例化并设置为None(除非i 为该行提供了默认的值或特定值)。访问该实例的属性时，返回的时该行的值而不是Filed的子类。与之类似，值可以以一种直观的方式编写，而不再需要Filed参与
	本质上，元类所完成的工作时接受声明，重组类属性的结构，然后使用新结构创建类
```

优势

```
	设计API时该模式非常有效，一个优秀API的主要目标时尽可能简单，并且尽量少包含用力代码。这意味着不仅声明类应该简单直接，而且使用该类也应该简单直接
	在Django模型示例中，这两个目标有冲突，但ModelBase元类解决了。
	使用元类时填补这一缺口的优秀方式。本质上它们童工将类声明置于前台，然后在__new__中将该类的声明转换为实际类的结构
```

- 类验证

若一个类必须遵循特定接口，元类将会是强制使其符合规范的有效方式。通常，倾向于使用合理的默认值解决，但优势这并不现实

如，一个类需要设置两个属性中的一个，但不需要两个属性都设置。若其中一个属性设置为unset(与设置None相反)，就很难通过合理的默认值实现，可以使用元类实现

```python
class FooOrBar(type):
    def __new__(cls, name, bases, attrs):
        if 'foo' in attrs and 'bar' in attrs:
            raise TypeError('Class %s cannot contain both 'foo' and 'bar' attribute.' % name)
        if 'foo' not in attrs and 'bar' not in attrs:
            raise TypeError('Class %s must provide either a 'foo' attribute or a 'bar' attribute.' % name)
        return super(FooOrBar, cls).__new__(cls, name, bases, attrs)

# 工作正常
class Valid(metaclass=FooOrBar):
    foo = 42
    
# 报错
class Invalid(metaclass=FooOrBar):
    pass
# 报错
class Invalid(metaclass=FooOrBar):
    foo = 42
    bar = 24
```

这个特定的实现存在一个问题。它的子类并不会继承该功能。原因是元类直接检查attrs属性，但这只包含所声明的类的属性集。它并不知道任何继承自基类的属性

```python
class Valid(metaclass=FooOrBar):
    foo = 42

# 报错
class AlsoValid(Valid):
    pass
```

用另一种通过检查基类属性实现FooOrBar元类的方式

```python
class FooOrBar(type):
	# 在实例化类返回之前检查它的属性，而不是查看attrs 
    def __new__(cls, name, bases, attrs):
        # 调用type的构造函数从基类获得所有属性。因此，对hasattr的调用正常工作，而不必管属性是当前类中声明还是继承自基类
        answer = super(FooOrBar, cls).__new__(cls, name, bases, attrs)
        if hasattr(answer, 'foo') and hasattr(answer, 'bar'):
            raise TypeError('Class %s cannot contain both 'foo' and 'bar' attribute.' % name)
        if not hasattr(answer, 'foo') and not hasattr(answer, 'bar'):
            raise TypeError('Class %s must provide either a 'foo' attribute or a 'bar' attribute.' % name)
        return answer
```

在不使用元类的情况下也可实现。可以通过编写一个简单方法接受该类作为参数并完成同样的检查。实际上，这是一种用于装饰器的优秀方式，但必须手动将该类发送给验证方法。而使用元类，就只需要在创建类时处理。有时，显式检查更可取；但其他以后却不然，仅仅取决于用例

- 非继承属性

可以将元类用作一种工具，使类中特定的属性不会自动继承。想要这样做的最常见场景时与其他元类行为结合。

如，假设一个元类为它的类提供功能，但一些类被创建为抽象类，因此并不希望所谓的功能在这种情况下执行。实现这一点，显而易见的一种方式是允许类设置abstract属性，并且仅在abstract未设置或设置为False时才执行元类的特殊功能。

```python
class Meta(type):
    def __new__(cls, name, bases, attrs):
        # 语法检查，若是抽象类，则不执行元类方法
        if attrs.get('abstract', False):
            return super(Meta, cls).__new__(cls, name, bases, attrs)
        # 执行元类方法
        pass
```

但这种方法存在一个问题，与其他属性类似，子类将继承abstract属性，这意味着任何子类都需要显式声明自己并不是抽象类，显得怪异

```python
class AbstractClass(metaclass=Meta):
    abstract = True
    
class RegularClass(AbstractClass):
    abstract = False
```

直觉上，希望在所有抽象类中声明abstract属性，但对于该属性不应该继承。实现时，并不需要像元类那样读取attrs字典，元类可以修改该属性，并在不需要时将该属性丢弃

```python
class Meta(type):
    def __new__(cls, name, bases, attrs):
        # 语法检查，若是抽象类，则不执行元类方法
        if attrs.pop('abstract', False):
            return super(Meta, cls).__new__(cls, name, bases, attrs)
        # 执行元类方法
        pass
```

abstract属性在实际创建的类中被完全移除。在本例中，AbstracClass不会获得元类的功能，而且实际上abstract属性已经不存在。子类不再继承该属性。

## 显式选择

实际上，元类的大多数主要用例都可以不用元类解决。如，类装饰器可以很容易地处理类遵循特定接口的需求。但装饰所有类时一件繁琐的动作。装饰器可以确保设置了foo或bar，但很难确保同事设置了两个值

使用元类与使用装饰器的关键区别取决于最终类的使用方式，使用装饰器要求将类装饰器显式应用到每一个类，若程序员在实现子类的过程中忘记应用装饰器，就不会检查

元类时自动的，并且对声明和使用类的程序员透明。很少有API要求程序员直接使用元类，但其中很多API要求程序员继承由API包提供的基类。通过将元类赋给该基类，所有的子类也都会收到该元类。这使最终程序猿即使不了解元类的功能，也能应用该功能

简言之，显式比隐式更好。但只适用于大多数场景，直到遇到不合适的场景，如，提到外来信息或样板代码时，显式更好。与之类似，有时显式知识意味着更容易维护，但并不总是合适的。

## meta-coding

对于元类的操作增多，元类的优势凸显。将每个Django模型适用一个显式的装饰器进行标记并不合理且难以维护

与之类似，考虑元编码(meta-coding)的情景。在该上下文中，术语meta-coding指代用于查看应用程序中其他代码的代码。如，考虑应该记录其自身代码的代码

元类使一个类的实例记录所有对它自身的方法调用很容易实现。

```python
# Logged被声明为type子类
class Logged(type):
	"""元类导致其类记录它的函数调用(除了将结果打印到标准输出sys.stdout,而不是实际记录日志之外)"""
    def __new__(cls, name, bases, attrs):
        # 迭代attrs字典中的所有属性，检查它们是否为可调用的,若是，则对其进行包装
        for key, value in attrs.items():
            if callable(value):
                attrs[key] = cls.log_call(value)
        return super(Logged, cls).__new__(cls, name, bases, attrs)
    
    @staticmethod
    def log_call(fxn):
        """输入一个函数，使用日志代码封装，返回封装后的函数"""
        def inner(*args, **kwargs):
            print('The function %s was called with arguments %r and keyword arguments %r.' % (fxn.__name__, args, kwargs))
            try:
                response = fxn(*args, kwargs)
                print('The function call to %s was successful.' % fxn.__name__)
                return response
            except Exception as exc:
                print('The function call to %s raised an exception: %r' % (fxn.__name__, exc))
                raise
        return inner
```

使用

```python
class MyClass(metaclass=Logged):
    def foo(self):
        pass
    def bar(self):
        raise TypeError('oh noes!')
        

>>>obj = MyClass()
>>>obj.foo()  # 可调用，输出日志
>>>obj.bar()  # 可调用，输出日志，抛出异常
```

实例化MyClass时，并没有调用`__init__`的日志，虽然其是调用可调用的。原因是，元类便利attrs字典中所有属性，并没有在MyClass类中显式定义`__init__`。`__init__`方法继承自object，正是希望的行为。否则，子类会导致log_call装饰器对同一个可调函数重复应用，从而导致重复的print信息

```python
class MyClass(metaclass=Logged):
	def __init__(self):
        pass
    
>>>obj = MyClass()  # __init__被调用
```

要注意的是，即使并没有在python shell中显式调用`__init__`,仍然会记录该方法，这是由于在创建实例时，python解释器在底层调用了`__init__`方法

如果一个方法是在类创建之后被添加的(同行不应出现），该方法就不会被包装

```
>>>MyClass.foo = lambda self: 42
>>>obj.foo()  # 输出42，无输出日志
```

# 类工厂

类工厂是设计模式中的一种，本质上，类工厂就是一个正在运行时创建类的函数。该改娘允许创建类时根据情况决定其属性，如根据用户输入创建属性

即席生成类

```python
class Animal(object):
    """A class representing an arbitray animal"""
    def __init__(self, name):
        self.name = name
        
    def eat(self):
        pass
    
    def go_to_vet(self):
        pass
```

type类

```python
# 函数与类Animal位于同一层命名空间
def init(self, name):
    self.name = name
    
def eat(self):
    pass

def go_to_vet(self):
    pass

Animal = type('Aniam', (object,), {
    '__doc__': """A class representing an arbitray animal""",
    '__init__': init,
    'eat'; eat,
    'go_to_vet': go_to_vet,
})
```

## 类工厂函数

类工厂函数是一个用于创建并返回类的函数

### 使用type

```python
def create_animal_class():
    """使用内置的type方法创建"""
    def init(self, name):
    	self.name = name
    
	def eat(self):
   		pass

	def go_to_vet(self):
   		pass

	return type('Aniam', (object,), {
    	'__doc__': """A class representing an arbitray animal""",
    	'__init__': init,
    	'eat'; eat,
    	'go_to_vet': go_to_vet,
	})
```

之前混入到命名空间中的init,eat,go_to_vet函数全部转移到了create_animal_class函数中

需要注意的是，若多次调用create_animal_class函数会返回不同的类。尽管所返回的类有相同的名称和属性，其实他们并不是同一个类。这些类之间的相似性是基于每次远行函数时都会赋值相同的字典键和相似的函数

所返回类之间的相似性并不确定。函数不能接受一个或多个参数并返回不同类并没有具体的元婴。实际上，这也是类工厂函数的整个目的

````python
Animal1 = create_animal_class()
Animal2 = create_animal_class()
Animal == Animal2  # False

animal1 = Animal1('louisoix')
animal2 = Animal2('louisoix')

isinstance(animal1, Animal1)  # True
isinstance(animal1, Animal2)  # False
````

### 使用class

```python
def create_animal_class():
    """使用内置class关键字创建"""
    class Animal(object):
        """A class representing an arbitray animal"""
        def __init__(self, name):
            self.name = name
            
        def eat(self):
            pass
        
        def go_to_vet(self):
            pass
        
    return Animal
```

多数情况下，使用class关键字而不是直接调用type创建类更加可行，但并不适用于所有情况

## 使用时机

编写类工厂函数的主要原因是需要基于运行时的信息(如用户输入)创建类时。而class关键字假定已经在编码时知道需要赋值给类的属性(非必要)，若在编码时并不知道许哟啊赋值给类的属性，类工厂函数将会是一个方便的替代方法

### 运行时属性

下面创建类的函数，该类的属性可以基于传递给函数的参数而变化

```python
def get_credential_class(use_proxy=False, tfa = False):
    """请求获得所发生的登陆类型的信息，该类的属性可以基于传递给函数的参数而变化"""
    # 若是OpenID服务登陆，需要服务的名字和邮箱
    if use_proxy:
        keys = ['service_name', 'email_address']
     else:
        # 传统登陆方式，用户名和密码
        keys = ['username', 'password']
        # 若是需要双因素认证，则需验证令牌
        if tfa:
            keys.append('tfa_token')
     
    class Credential(object):
        excepted_keys = set(keys)
        def __init__(self, **kwargs):
            # 检查从expected_keys属性中获得的关键字参数
            # 若是不匹配，则抛出异常
            if self.expected_keys != set(kwargs.keys()):
                raise ValueError('Keys do not match')
            # 若是匹配，将keys写入credential实例
            for k, v in kwargs.items():
                setattr(self, k, v)
    # 返回一个类，而不是一个实例，用于表示合适的凭据类型
    # 若将use_proxy设置为true，则返回的类包含设置为['service_name', 'email_address']的expected_keys属性，代表通过代理身份验证所要的密钥
    # 若将use_proxy设置为false，将返回带有不同expected_keys属性的类
    return Credential
```

> 这样做的原因

仅有三种可能习惯，硬编码这些类而不是即席动态创建类，并不合理，毕竟大量网站并不会使用多种验证方式。
并没有一个网站需要通过编程方式来决定使用哪个凭证，但假如是一个为大量不同的第三方网站提供凭据的服务就不同了。这类网站更倾向将所需的键于值类型存储在数据库中
现在突然间有了一个能够根据数据库查询结果生成属性的类。因为数据库查询在运行时而不是在编码时发生。这个类可以拥有无限中expected_keys属性，而完全靠手动比那吗实现不现实
将这类数据存入数据库同时也意味着，随着数据改变，代码无须更改。一个网站或许需要修改或增加它支持的凭据类型，现在只需要在数据库中添加或删除行即可，而Credential类却不需要更改即可继续使用

> 属性字典

仅仅是某些属性只有在执行时可知并不是使用类工厂的必要条件。常常，可一即席将属性写入类，或是类仅仅存储一个包含任意属性集合的字典

若该方案可行，则该方案就更简单、直接

```python
class MyClass(object):
    attrs = {}
```

属性字典的缺点在于，当写一个子类继承现有类，而现有类无法直接控制时，需要现有的功能可以对修改过的属性进行操作

> 扩充Credential类

考虑一个只有一个表的credential数据库，该表只有两列，一列是服务名称(Apple,Amazon)，一列是凭据键(username)。现在从该数据库(CSV平面问价方式存储)读取数据并返回适当类的类工厂

```python
import csv

def get_credential_class(service):
    # 打开数据库
    keys = []
    with open('creds.csv', 'r') as csvfile:
        for row in csv.reader(csvfile):
            # if the row does not correspond to the service we are actually asking for, skip it
            if row[0].lower() != service.lower():
                continue
            # add the key to the list of expected keys
            keys.append(row[1])

    # return a class with a proper __init__ method which expects all expected keys
    class Credential(object):
        expected_keys = keys
        def __init__(self, **kwargs):
            # sanity check: Do our keys match
            if set(self.expected_keys) != set([i for i in kwargs.keys()]):
                raise ValueError('keys do not match')
            # write the keys to the credential object
            for k, v in kwargs.items():
                setattr(self, k, v)
    return Credential
```

现在get_credential_class函数输入部分被完全替换，参数不再是凭据类型，而是用来指定谁使用该凭据

```
# 一个csv数据库
Amazon, username
Amazon, password
Apple, email_address
Apple, password
Github, username
Github, password
Github, auth_token
```

get_credential_class接受的值是一个字符串，与CSV文件的第一列对应。因此，调用`get_credential_class(Github)`将会返回一个包含username, password与auth_token属性的类。CSV文件中与Apple和Amazon对应的行将被跳过

> 表单示例

可以从Djanog的表单API中看到该概念的应用。该框架包含一个抽象类，django.forms.Form，用于创建HTML表单

Django表单有一个接受在表单中声明属性与表单域和表单数据分隔符的自定义元类。若是知道是哪一个表单域，那么在API中创建一个凭据表单非常容易

```python
from django import froms

class CredentialForm(forms.Form):
    username = forms.CharField()
    password = forms.CharField(widget=forms.PasswordInput)
```

若是不知道是哪一个域，将会是非常复杂的任务，类工厂就是很好的解决方案

```python
import csv
from django import forms

def get_credential_form_class(service):
    # 打开数据库
    keys = []
    with open('creds.csv', 'r') as csvfile:
        for row in csv.reader(csvfile):
            # if the row does not correspond to the service we are actually asking for, skip it
            if row[0].lower() != service.lower():
                continue
            # add the key to the list of expected keys
            keys.append(row[1])
    # put together the approprivate credential fields
    attrs = []
    for key in keys:
        field_kw = {}
        if 'password' in key:
            field_kw['widget'] = forms.PasswordInput
        attrs[key] = forms.CharField(**field_kw)
    # return a form class with the appropriate credential fields
    metaclass = type(forms.Form)
    return metaclass('CredentialForm', (forms.Form,), attrs)
```

在本例中，将自定义Credential类替换为Django form的子类。不再续哟啊设置expected_keys属性。而是为每一个预期键设置一个属性。之前的代码将这些放入一个字典，并创建一个新的form子类返回

Django的Form类使用的是一个继承type的自定义元类。因此，调用其构造函数而不是直接使用type非常中哟啊。在最后两行中获得forms.Form元类，并直接使用其构造函数

在本例中，无法通过class关键字创建类，是由于，即使在一个函数内，无法创建类并将属性写入类，并且在类创建后，元类的行为将不再会被应用到该类的属性

### 避免类属性一致性

编写类工厂函数的另一个原因是处理类和实例之间属性不同的问题

> 类属性与实例属性

```python
# 类属性
class C(object):
    foo = 'bar'
    
# 实例属性
class I(object):
    def __init__(self):
        self.foo = 'bar'
        
        
# 访问
c = C()
i = I()
C.foo  # 'bar'
I.foo  # 报错
c.foo  # 'bar'
i.foo  # 'bar'
# 修改
c1 = C()
c2 = C()
c1.foo = 'baz'
c2.foo  # 'bar'
C.foo = 'bax'
c1.foo  # 'baz'
c2.foo = 'baz'
```

> 类方法的限制

类方法是并不需要类的实例就可以执行的方法，但需要类本身。常常使用`@classmethod`装饰器装饰一个方法来完成声明，且方法的第一个参数按照传统是cls而不是self

```python
class C(object):
    foo = 'bar'
    
    @classmethod
    def classfoo(cls):
        return cls.foo    
```

类方法中只能访问类的属性，不能访问实例属性

> 使用类工厂

需要类工厂的一个最大原因是当你继承一个现有类并且所依赖的类属性必须调整时

本质上，在无法控制的代码中，若一个已存在的类设置某个必须自定义的类属性，类工厂是生成带有重载属性的恰当子类的一种恰当方式

考虑一种情况，当一个类中包含了必须在运行时(或是在静态代码中子类的选择过多时)被重载的属性。在这种情况下，类工厂将会是一个非常有效的方案

```python
def create_C_subclass(new_foo):
    class SubC(C):
        foo = new_foo
    return subC
```

并不需要在类创建之前，也就是函数运行时，知道foo值。与其他大多数类工厂的使用并无二致，都是关于在运行时获得属性值

```python
>>> S = create_C_subclass('spam')
>>> S.classfoo()
>>> S = create_C_subclass('eggs')
>>> S.classfoo()
```

在很多情况下，创建一个仅仅在`__init__`方法中接受该值的子类就简单多了。然而，也有一些轻卡 u 功能使用这种方法并不可行，例如，父类依赖于类方法，此时讲一个新值赋给实例并不会导致类方法接收到新值。这时该子类创建的模型将会是一个有价值的解决方案

### 关于单例模式

让类工厂函数难以使用的一点是类工厂返回的是类，而不是类的实例。若需要一个实例，则必须调用类工厂函数返回的结果才可以。

有些时候，通过类工厂创建的类共嗯那个上类似单例模式。单例模式是一种只允许一个实例的类模式

在函数中生成类的情况下，有可能函数的目的就是作为一个类构造函数。最终开发人员必须不断考虑如何再次实例化所生成的类。如果不需要面对在其他的地方重用类或类工厂可以处理类重用的情况，就不需要处理这种情况，让类工厂返回其创建类的实例而不是类本省完全是合理且有用的。

```python
def CPrime(new_foo='bar'):
    # 若foo是bar，则不必自定义类
    if new_foo = 'bar':
        return C()
    # 创建自定义类
    class SubC(C):
        foo = new_foo
    return SubC()
```

调用CPrime将会返回合适的C子类的实例，该类带有按需修改后的foo属性。但是，存在一问题，很多类需哟啊将参数发送给`__init__`方法，此时该函数就无法处理这种情况

```python
import csv
from django import forms

def get_credential_form(service, *args, **kwargs):
    """返回一个表单实例"""
    # 打开数据库
    keys = []
    with open('cred.csv', 'r') as csvfile:
        for row in csv.reader(csvfile):
            if row[0].lower() != service.lower():
                continue
                
             # 添加key
             keys.append(row[1])
    # 集中凭据
    attrs = {}
    for key in keys:
        field_kw = {}
        if 'password' in key:
            field_kw['widget'] = forms.PasswordInput
        attrs[key] = forms.CharField(**field_kw)
    # 返回一个表单类实例
    metaclass = type(forms.FOrm)
    cls = metaclass('CredentialForm', (forms.Form,), attrs)
    return cls(*args, **kwargs)
```

对于最终开发人员来说，很容易将函数与一个类混淆，除非查看内部工作机制。因此，或许应该将函数的信息写到开发规范的命名约定中

```python
def CredentialForm(service, *args, **kwargs):
	...
```

在python中，函数常以小写字母命名，并用消化腺作为单词分隔符。然而该函数被实际使用它的开发人员用做类构造函数，因此修改命名约定，表示CredentialForm是一个类名称。另外，这种命名方式也与用于实例的类的名称相匹配，由于第一个参数与元类的构造函数相配，因此CredentialForm是类的内部名称

# 抽象基类

在处理编程和对象时，问题通常可以转化为一个对象是否实现了给定方法，或包含一个特定属性。如果这个独享有一个quack方法，就有恰当证据证明它时一只鸭子。此外，若只需要一个quack方法，实际上它是否时一只鸭子就不重要了

这通常是有用的构造，并且比较易于在python这种松散类型系统中实现。它强调构成而不是身份，强调hasattr函数而不是isinstance函数。但是，有时身份很重要，如假设正在使用要求遵循特殊身份的类库。或者，有时检查不同种类的属性和方法显得过于频繁时。

python2.6和python3中引入了抽象基类的概念。抽象基类是一个分配身份的机制。它是回答"从本质上讲，这是一只鸭子吗？"这一问题的一种方式。抽象基类也提供了一个表明抽象方法的机制，就是要求其他实现提供关键性功能，这些功能是在基类实现中不主动提供的功能

## 使用抽象基类

抽象基类的基本目的是提供有点形式化的方法，来测试一个对象是否符合特定规范。

```python
# 确定对象是列表
isinstance([], list)  # True
isinstance(object(), list)  # False

# 确定对象像列表，且不会修改对象
isinstance([], (list, tuple))  # True
isinstance((), (list, tuple))  # True
isinstance(object(), (list, tuple)  # False

# 测试__gettem__
hasattr([], '__getitem__')  # True
hasattr(object(), '__getitem__')  # False
# 不是完整的解决方案，不产生false结果，相反，会产生true结果。因为不仅仅只有类似列表的独享实现了__getitem方法
hasattr({}, '__getitem__')  # True
```

从本质上讲，仅仅对某个属性或者方法是否存在进行测试有时不足以确定该对象是否符合所寻找的参数。

抽象基类听过了声明一个类是另一个类的派生类的机制(无论它是否是另一个类的派生类)。该机制并没有影响实际的对象继承关系或事改变方法解析顺序。其目的是声明性的，它提供了一种断言对象符合协议的方式

此外，抽象基类提供了一种要求子类实现指定协议的方式，若一个抽象基类要求实现指定方法，并且子类没有实现这个方法，然后当试图创建子类时解释器会泡茶哦一个异常

## 声明虚拟子类

python2.6和3的所有版本都提供了一个名为abc(表示抽象基类)的模块，该模块提供了一些使用抽象基类的工具，abc模块提供的第一个内容是名为ABCMeta的元类。任何抽象基类必须使用ABCMeta元类

所有抽象基类可以任意地声明它是任意具体类的父类(不是派生类)，包括在标准库的具体类(甚至那些使用C语言实现的类)。ABCMeta的实例通过使用register方法提供了对声明的实现(使用ABCMeta作为它们元类的类都是类本身)

```python
# 注册自身作为dict的父类的抽象基类
import abc

class AbstractDict(metaclass=abc.ABCMeta):
    def foo(self):
        return None

>>>AbstractDict.register(dict)  # <class 'dict'>
```

并没有对dict类本身进行任何修改。在此没有发生显著的变化，至关重要的是，dict的方法解析没有发生改变。并不会突然发想dict拥有了foo方法。

这样做使得dict对象也被标识为AbstractDict的实例，并且现在dict自身也被标识为一个AbstractDict的子类

```python
isinstance({}, AbstractDict)  # True
isinstance(dict, AbstractDict)  # True
# AbstractDict不是dict的子类
isinstance(AbstractDict, dict)  # False
```

- 声明虚拟子类的原因

之前为了读取类似列表对象的实例，实例需要像list或tuple一样可被遍历，且需要一个`__getitem__`方法来接收整型参数。另一方面没有必要限制只接受list或tuple。使用isinstance来检查一个类的元组，但是这并不是真的可扩展。若在实现中检查list或tuple，并且使用此类库的人打算发送一些其他的类似列表的对象，而对象并不是list或tuple的子类，就遇到了难以实现扩展。抽象基类提供了解决此问题的方案

```python
# 定义一个抽象基类并且对它注册list和tuple
import abc

class MySequence(metaclass=abc.ABCMeta):
    pass
MySequence.register(list)
MySequence.register(tuple)

# 检查MySequence
>>>isinstance([], MySequence)  # True
>>>isinstance((), MySequence)  # True
>>>isinstance(object(), MySequence)  # False
```

当(list, tuple)在类库中是硬编码时，开发人员什么也做不了，但是MySequence是一个在类库中定义的抽象基类。开发人员可以导入它

```python
class CustomListLikeClass(object):
    pass
# 注册
MySequence.register(CustomListLikeClas)

>>> issubClass(CustomListLikeClas, MySequence)  # True
```

开发人员可以将CustomListLikeClass的实例传递给期望MySequence的类库。现在，当类库执行isinstance检测时，检查会通过，因此准许接受该对象

- 使用register作为装饰器

自python3.3以来，使用ABCMeta元类的类所提供的register方法也可以用作装饰器。在python2和python3.2及以前的版本中，抽象基类的register方法返回的结果是None，而不是被传递的类，故不能用作装饰器。

```python
# 创建一个应该被注册为ABCMeta子类的新类，则可以像下面一样注册它(使用MySequence抽象基类)
class CustomListLikeClass(object):
    pass
# 注册
MySequence.register(CustomListLikeClas)
```

register方法会返回传递给它的类。这样的工作机制使得register也能被用作装饰器。register接受一个可调用函数，同时返回一个可调用函数

```python
@MySequence.register
class CustomListLikeClass(object):
    pass
```

- `__subclasshook__`

对于大多数，使用一个ABCMeta元类的类，然后使用由ABCMeta提供的register方法就完全足以获得所需的结果。但是，为所有希望的子类手动注册这种情况并不合理

用ABCMeta元类创建的类可以有选择地定义一个特殊的魔法方法，为`__subclasshook__`。此方法必须被定义为一个类方法(使用@classmethod)且接收一个额外的位置参数，该参数是被测试的类。返回值是True,False或NotImplemented。当被测试类被认为是子类，则True，若被认为不是子类，则False

传统鸭子类型最根本问题是，一个对象是否有某个方法或者属性，而不是对象是否是这个类的子类。抽象基类可以用`__subclasshook__`实现这个概念

```python
import abc

class AbstractDuck(metaclass=abc.ABCMeta):
    @classmethod
    def __subclasshook_(cls, other):
        quack = getattr(other, 'quack', None)
        return callable(quack)
```

该抽象基类表明，任何带有quack方法(该方法不是一个不可调用的quack属性)的类都被认为是它的子类，而任何其他类都不是它的子类

```python
class Duck(object):
	def quack(self):
        pass
    
class NotDuck(object):
    quack = 'foo'
    
>>>issubclass(Duck, AbstractDuck)  # True
>>>issubclass(NotDuck, AbstractDuck)  # False
```

当魔法方法别定义时，优先于register方法

```python
>>>AbstractDuck.register(NotDuck)
>>>issubclass(NotDuck, AbstractDuck)  # False
```

在此需要用到Not Implemented.若`__subclasshook__`方法返回Not Implemented,然后(并且只有然后)传统检测的路径就会查看已注册的类是否已被选中

```python
import abc

class AbstractDuck(metaclass=abc.ABCMeta):
    @classmethod
    def __subclasshook_(cls, other):
        quack = getattr(other, 'quack', None)
        if callable(quack):
            return True
        return NotImplemented
# 注册表已经被检查，并且之前注册的类将作为子类返回
>>>issubclass(NotDuck, AbstractDuck)  # False
>>>AbstractDuck.register(NotDuck)  # <class '__main__.NotDuck'>
>>>issubclass(NotDuck, AbstractDuck)  # True
```

本质上讲，第一个例子是说"若它叫起来像只鸭子，那么它就是AbstractDuck"，第二个例子是说"若它叫起来像只鸭子或者直接说它是AbstractDuck，那么它就是AbstractDuck"

如果这样做，就必须能够处理接受的任何东西，如果依赖于调用quack方法，那么使得该方法可选择没有任何好处。这样做可以仅简单针对所需的方法做hasattr或callable检查

在一种相对简单的情况下，使用抽象基类或许实际上是一个障碍，如使用一个替身来检查单一方法是否存在只会增加不必要的复杂度。对于复杂的情况，使用抽象基类就有价值了。首先，在区分上有价值。抽象基类为整个测试定义了一个存在的同一位置。使用抽象基类子类的任何代码仅仅是使用issubclass或isinstance方法。随着需求的变化，仅在一个地方存放一致性检查的代码。另外，NotImplemented作为`__subclasshok__`的可用返回值增加了一些功能。提供了一种确保绝对匹配或不匹配给定协议的机制，也是对于自定义类作者显式可选的方式

## 声明协议

已经介绍了抽象基类是如何使一个类能够声明它自身可以通过类型检查测试的，抽象基类的另一个主要价值在于它有声明协议的功能。可以定义子类必须提供的内容。类似于如java等面向对象的语言中接口的概念

### 其他现有的方法

即使不使用抽象基类也能解决这种问题， 如下方法

- 使用NotImplementedError

考虑一个构建为带有特定功能的类，但是这个类省去了一个关键方法，以便这个方法可以被子类实现

```python
from datetime import datetime

class Task(object):
    """An abstract class reresenting a task that must run, and which should track individual runs and results"""
    def __init__(self):
        self.runs = []

    def run(self):
        start = datetime.now()
        result = sef._run()
        end = datetime.now()
        self.runs.append({
            'start': start,
            'end': end,
            'result'; result,
        })
        return result

    def _run(self):
        raise NotImplementedError('Task subclass must define a _run method')
```

这个类目的是运行某种类型的人物并追踪何时执行这些人物，也能提供日志记录或类似功能。但是，基类Task不能提供人物主体。这需要由子类万层呢，相反，Task类提供一个shell方法`_run`，该方法仅抛出带有有用错误信息的NotImplementedError。任何未能充血`_run`的子类大都会引发这个错误，若想调用Task类本身的run方法，也会抛错

```python
t = Task()
r.run()  # 抛出NotImplementedError
```

- 使用元类

```python
from datetime import datetime, timezone

class TaskMeta(type):
    """A metaclass that ensures the presence of a _run method on any non-abstract classes it creates"""
    def __new__(cls, name, bases, attrs):
        # if this is an abstaract class , do not check for a _run method
        if attrs.pop('abstract', False):
            return super(TaskMeta, cls).__new__(cls, name, bases, attrs)
        
        # create the resulting class
        new_class = super(TaskMeta, cls).__new__(cls, name, bases, attrs)

        # verify that a _run method is present and raise TypeError otherwise
        if not hasattr(new_class, '_run') or not callable(new_class._run):
            raise TypeError('Task subclasses must define a _run method.')

        # return the new class object
        return new_class

class Task(metaclass=TaskMeta):
    """A abstract class representing a task that must run, and which should track individual runs and results."""
    abstarct = True
    def __init__(self):
        self.runs = []

    def run(self):
        start = datetime.now(tz=timezone.utc)
        result = self._run()
        end = datetime.now(tz=timezone.utc)
        self.runs.append({
            'start': start,
            'end': end,
            'result': result,
        })
        return result
```

Task类本身虽然仍然被实例化，但是不再声明`_run`方法，因此面向公用的run方法会抛出AttributeError错误

```python
>>> t = Task()
>>> t.run  # 抛出AttributeError
```

当子类被创建时元类会运行`__new__`方法，解析器讲不再允许创建没有`_run`方法的子类

```python
>>> class TaskSubclass(Task):
    	pass
    # 抛出NotImplementedError
```

### 抽象基类的价值

以上两种方法都有价值，但是缺点是"即席(ad hoc)".

抽象基类提供了一种呈现相同模式的更正式的方法。它们提供了一个使用某个抽象基类声明协议的机制，并且子类一定要提供一个符合该协议的实现

abc模块提供了一个名为@abstractmethod的装饰器，它制定了一个必须被所有子类重写的特定方法。该方法体可以是空的(pass)，或者可能包含一个子类方法可能选择使用super调用的实现

```python
# 使用@abstractmethod替代自定义元类的Task类
import abc
from datetime import datetime, timezone

class Task(metaclass=abc.ABCMeta):
    """A abstract class representing a task that must run, and which should track individual runs and results."""
    abstarct = True
    def __init__(self):
        self.runs = []

    def run(self):
        start = datetime.now(tz=timezone.utc)
        result = self._run()
        end = datetime.now(tz=timezone.utc)
        self.runs.append({
            'start': start,
            'end': end,
            'result': result,
        })
        return result
    
    @abc.abstractmethod
    def _run(self):
        pass
```

Task类本身不能被实例化，与NotImplementedError方法不同，NotImplementedError允许基类Task被实例化

```python
>>> t = Task()  # 抛出TypeError
```

当使用抽象基类时，解析器乐于去创建一个不实现基类中所有(或任一)抽象方法的子类，但是解析器不愿做的就是实例化这个类。实际上，这样做给粗的错误信息与Task类给出的完全一样

```python
class Subtask(Task):
	pass

>>>st = Subtask()  # 抛出TypeError
```

但是，一旦定义一个重写抽象方法的子类，就可以正常工作且能实例化子类

```python
class OtherSubtask(Task):
	def _run(self):
        return 2 + 2
    
>>> ost = OtherSubtask()
>>> ost.run()  # 4
>>> ost.runs  # [{....}]
```

实际上，基于以下几个原因，这时解决这个问题的一个非常有用的方法。

```
	首先，这个方法时正式而不是临时的，抽象类被明确地提出作为满足这种特定需求的解决方案，依据这一概念，理想情况下应该有且仅有一种实现这种需求的“正确”方法
	其次，@abstractmethod装饰器非常简单，且可以在打算编写一个模版代码时避免出现大量潜在错去。如，若在TaskMeta元类中意外地仅检查attrs字典中存在_run，而不允许子类中存在_run会如何？很容易犯错，并且会导致Task子类不能成为自身的子类，除非每次都手动重写_run方法。使用@abstractmethod装饰器，将不用过多考虑的清咖滚下获得正确的行为
	最后，这个方法使得引入中间实现变得容易。考虑一个有10个抽象方法而不是1个抽象方法的抽象基类。理所当然会有一个完整的子类树，在树中链上的高级别的子类实现一些常用方法，但是将在抽象状态中的方法留给其他子类去实现。也能使用自定义元类方法实现该功能(在TaskMeta示例中，通过在每一个中间类中声明abstract=True)。但是，当使用@abstractmethod装饰器时，基本上能够得到直观上希望的行为
	当然，需要这类功能时，若所需支持的python版本不包含abc模块，那么这是一个不使用抽象基类的充足理由
```

### 抽象属性

也可以将属性声明为抽象属性(使用@property装饰器)。但是实现此目的的正确方法取决于所支持的python版本

python2.6到3.2

````python
import abc

class AbstractClass(metaclass=abc.ABCMeta):
    @abc.abstractproperty
    def foo(self):
        pass
````

python3.3及以上，@abstractmethod被更新到能与@property共同协作

```python
import abc

class AbstractClass(metaclass=abc.ABCMeta):
    @property
    @abc.abstractmethod
    def foo(self):
        pass
```

实例化AbstractClass的子类且不重写foo方法引发错误

```python
>>> class InvalidChild(AbstractClass):
    	pass
>>> ic = InvalidChild()  # 抛TypeError
```

重写抽象方法的子类能够被实例化

```python
class ValidChild(AbstractClass):
    @property
    def foo(self):
        return 'bar'
 
>>> vc = ValidChild()
>>> vc.foo  # 'bar'
```

### 抽象类或静态方法

与属性一样，可能希望将@abstractmethod装饰器与一个类方法或静态方法组合使用(@classmethod或@staticmethod)

在python2.6~3.1版本中没有方法实现。python3.2提供了一种实现方式，是使用@abstractmethod或@abstractstaticmethod装饰器实现，与之前的抽象属性类似。python3.3后，通过修改@abstractmethod从而兼容@classmethod或@staticmethod装饰器改变了这一点，且废弃了python3.2版本的方法

```python
class AbstractClass(metaclass=abc.ABCMeta):
    @classmethod
    @abc.abstractmethod
    def foo(cls):
        return 42
```

继承该类的子类在未重写该方法的情况下能够正常工作，但是子类不能实例化

```python
class InvalidChild(AbstractClass):
    pass

>>> ic = InvalidChild()  # TypeError
```

抽象发发本身能够被直接调用，且不会引发任何异常

```python
>>> InvalidChild.foo()  # 42
```

抽象方法被重写，就可以实例化该子类

```python
class ValidChild(AbstractClass):
	@classmethod
    def foo(cls):
        return 'bar'
    
>>>ValidChild.foo()  # 'bar'
>>>vc = ValidChild()
>>>vc.foo()  # 'bar'
```

## 内置抽象基类

除了通过abc模块建立自己的抽象基类之外，python3标准类库也提供了少量内置抽象基类，尤其是选择使用一些特殊类用于实现常用模式(序列，可变序列，迭代器等)。最常用的抽象基类是用于集合的抽象基类，存在于collections.abc模块中

绝大多数内置的抽象基类都提供了抽象和非抽象的方法，并且通常是继承python内置类的替代方法。如，继承于MutableSequence相对于继承list或str可能是更好的选择

抽象基类能被划分为两种基本类别：需要和检查单一方法(如Iterable和Callable)；作为普通内置python类型的替身

- 只包含一个方法的抽象基类

提供了5个抽象基类，每个基类包含一个抽象方法，且抽象基类的`__subclasscheck__`方法仅仅检查该方法是否存在。

```
Callable(__call__)
Container(__contains__)
Hashable(__hash__)
Iterable(__iter__)
Sized(__len__)
```

任何包含响应方法的类都会自动地被当作相关抽象基类的子类

```python
from collections.abc import Sized

class Foo(object):
    def __len__(self):
        return 42
    
>>> issubclass(Foo, Sized)  # True
```

类可以直接作为抽象基类的子类，并期望重写相关方法

```python
class Bar(Sized):
    pass

>>> b = Bar()  # TypeError
```

除了这5个抽象类，还有一个抽象基类Iterator，它继承自Iterable，提供`__iter__`的实现(就是返回自身并可以被重写)，并且添加抽象方法`__next__`

- 可供集合使用的抽象基类

在python3中，另一个主要类型的内置抽象基类是那些用于识别与python主哟啊集合类(list,dict,set)功能类似的子类

有6个这样的类，它们每两个一组(包含一个不可变类和一个可变类)被划分为三个类别。

```
第一类是Sequence和MutableSequence。这两个抽象基类在python中分别起到类似于远足或着列表的作用。Sequence抽象基类只需要__getitem__和__len__方法。但是，它也提供许多用于列表和元祖的其他常用方法的实现，如__contains__和__iter__方法等。这里的主要目的在于可以继承Sequence并仅仅定义需要的内容，且python提供序列的其他常用功能，当然，list、tuple和set也都被当作Sequence的子类

MutableSequence也类似，但是它引入了即席修改序列的概念。因此，它添加__setitem__,__delitem__,inster方法作为抽象方法，且为append，pop提供功能。原则仍然相同，必须仅定义所需要的内容作为可变序列，并且python为其他情况提供了一个类似列表的方法。list和set已经被认为是MutableSequence的子类

其他两个类别是Mapping和Set，Mapping和Set与MutableMapping和MutableSet一起出现。Mapping用于类似字典(dictionary-like)的对象(与dict相似，且dict被认为是它的子类)，而Set用于无序的集合(与set类似，且set被当作一个子类)。在这两情况下，它们指定一些关键方法(使用dict和set对应的名称)作为抽象方法，并为除关键方法之外的其他部分提供实现
```

使用内置抽象基类

```
这些抽象基类的主要目的是提供一个测试常用集合类型的方法。而不是仅仅测试对象是否是一个list，而是检测是否为MutableSequence(或者不需要修改，可以只检测是否为Sequence对象)。不检测是否为dict对象，而是检测是否为MutableMapping对象。

这使得代码更加灵活，若使用类库的人不需要为单独目的创建一个类似类表的对象或一个类似字典的对象，他仍然可以将对象传递给你的代码，不需要做额外的工作就可以使用这些独享。这使得你的代码可以对对象进行测试，确保得到的对象是所期望的对象，并且有了允许传入兼容对象的灵活性，从而使得传入对象可以不是你所期望的具体对象
```

- 额外的抽象基类

标准库中还有其他一些抽象基类，如,numbers模块包含用于实现不同类型数字的抽象基类



