[TOC]

# 魔法属性

魔法方法被设计用于重载python的操作符或内置方法。魔术方法可以通过`__`语法定义，从而避免程序员在没有意向使用重载时碰巧定义了同名方法。魔术方法使内置类（包括诸如整型和字符串等基本类型）提供的约定与自定义类提供的约定保持一致。

当口头提到该方法时，`__init__`发音dunder-init

每个魔法方法都有特定的目的，当特定语法出现时，它作为执行的钩子(在特定事件发生时，能够响应事件而调用的代码或函数)

## 执行

对于`__init__`方法，在代码中并没有直接调用，仅仅是python的解释器知道在对象初始化时调用该方法

所有的魔法方法都是需要特定的函数名称与方法签名(有时签名是一个变量)，然后该方法就会在特定的情况下被解释器调用

## 常见方法

### 创建与销毁

该类方法在类的实例创建或销毁时执行

```python
__init__()
# 在创建实例后会立即执行对象的__init__方法,此方法为创建后的对象提供初始化数据。
# 初始化函数，并没有创建新对象(__new__)，无返回值，不能return，未创建时，python默认自动创建,
# 默认第一个参数是self,然后可以接受任意数量的必要和可选位置参数，以及任意数量的关键字参数

__new__()
# 在__init__之前执行，用于创建类的实例
# 必须有返回值，为类的实例对象，未创建时，Python默认调用父类自动创建
# 只有在通过__new__方法返回当前类的实例时才执行__init__方法，若返回的不是当前类的实例，则不会调用__init__方法
# __new__方法是静态的，无需显式装饰，第一个参数是cls，代表要实例化的类，在实例化时由Python解释器自动提供
# 在大多情况下，方法的其他参数会被完整复制到__init__方法中。
# 实际使用，无需定义此方法，内置实现已够用。
# 在重写new方法的时候，几乎都需要首先在实现本类逻辑之前引用父类的实现，可以return父类__new__出来的实例，或直接是object的__new__出来的实例
def __new__(cls, *args, **kwargs):
    # 可以super()或者父类名或者object
    return object.__new__(cls)

__del__()
# 载对象被销毁时被调用
# 只有一个参数self，无返回值，通常由垃圾回收器触发，无法引起任何有意义的异常
# 若无__del__,当使用类创建一个对象后，待程序执行完成后，对象默认会自动销毁。当对象销毁后，会触发其类的__del__方法
# 若有__del__，对象引用结束，程序未结束时，python会自动调用__del__方法
# 当变量保存了多次对象引用后，对象计数器增加，只有使用del(),把对象全部销毁，计数器为0时，才能触发__del__方法
```

### 类型转换

在python中存在多个用于将复杂对象转换为简单对象或常用数据类型的魔术方法，如str,int,bool等。对于复杂对象来说知道自身使用简单类型的等价表示十分有用

```python
__str__,__unicode__,__bytes__
# __str__接受一个位置参数self，并在对象被传递给str的构造函数时被调用，返回一个字符串
# 当通过str的参数遇到格式化字符串%s时，也会被调用，在python2中会首先尝试__unicode__
# 未创建时，默认情况下，打印对象是输出对象的内存地址
# 若重写了__str__魔法方法，会打印这个方法返回的字符串，作为这个对象的描述信息,若直接输出，输出对象的内存地址
# __unicode__在对象传递给unicode的构造函数时被调用，返回合适的类型，适用python2
# __bytes__在对象传递给bytes的构造函数时被调用，返回合适的类型，适用python3
# 在python2中，字符串使用ASCII字符串，存在Unicode编码的字符串
# 在python3中，字符串使用Unicode字符串，引入了bytes类型
class MyObject(object):
    def __str__(self):
        return 'hi'

str(MyOject()) # 输出'hi'
'This is %s' % MyObject()

class Which(object):
    def __str__(self):
        return 'string'
    def __unicode__(self):
        return u'unicode'
    
u'The %s was used' % Which()
'This %s was used' % Which()


__bool__,__nonzero__
# 对象需要界定True或False，无论时通过表达式转换为布尔类型，还是在某些情况下需要该对象布尔类型的等价形式(if语句)
# 接受一个位置参数并返回True或False
# 通常不需显式定义一个__bool__方法，若无定义__bool__，但定义了__len__,就将适用后者，从而导致重复
# 在python3中，该类型由__bool__处理
# 在python2中，该类型由__nonzero__处理

__int__,__float__,__complex__
# 将复杂对象转为基本类型的数字。如果一个对象定义了一个返回INT类型的__init__方法，那么该对象被传递给int的构造函数时，int方法会被调用。如果对象定义了__float__,__complex__方法，那么这些方法会在各自传递给float或complex的构造函数时被调用
```

### 比较

对象在进行相等性测试(==或!=)或不等性测试(<,<=,>,>=)时进行比较，这些操作符与python中的魔法方法一一对应

#### 二元相等性

下面的方法支持使用==或!=进行相等性测试

```python
__eq__
# 在两个对象使用==操作符进行比较时被调用。必须接受两个位置参数(self,other),是需要比较的两个对象
# 一般情况下，首先检测左边对象的__eq__方法是否存在，若存在则调用(不再返回NotImplemented).否则，使用右边对象中定义的__eq__方法(参数位置对调)
# 当被比较的两个对象中一个对象是另外一个对象的直接子类，将使用子类的__eq__方法
class MyClass(object):
    def __eq__(self, other):
        print(self, other)
        return self is other

c1 = MyClass()
c2 = MyClass()
c1 == c2
c2 == c1
c1 == c1

class MySubclass(MyClass):
    def __eq__(self, other):
        print(self ,other)
      	return False
    
MySubclass() == MyClass()
MyClass() == MySubclass()  


__ne__
# 在使用!=操作符时使用，与__eq__方法的功能相反
# 通常无须定义__ne__方法，只需针对__eq__方法的返回值取反即可。若时没有定义__ne__方法，则python会调用__eq__方法，并对结果取反
```

#### 相对比较

以下方法处理比较操作符来测试相对值(>)

```python
__lt__,__le__,__gt__,__ge__
# 分别与<,<=,>,>=操作符相匹配。上述方法都接受两个参数(self,other),并在相对比较时根据运算符结果返回True或False
# 通常无须全部定义这四个方法，python解释器会认为__lt__是__ge__取反，__gt__是__le__取反；同理，解释器会认为__le__是由__lt__和__eq__分离得来，__ge__是由__gt__和__eq__分离得来；实际上只需定义__eq__和__lt__(或__gt__)，则所有6个比较操作符就能按照预期正常生效
# 注意：这些方法内置了用于排序对象的sorted函数。因此，若有一个列表中的所有对象都定义了这些方法，将对象传递到sorted就会基于比较方法的结果自动返回一个升序排序后的列表

__cmp__
# 为对象定义相对比较的旧有(不推荐)方式，只有之前描述的方法未被定义时，才检查该方法是否被定义
# 该方法接受两个位置参数(self,other),若self比other小，那么返回一个负数；若是self比other大，返回一个正整数，若是相等，则返回0
# python2中已淘汰，python3中不可用
```

#### 操作符重载

提供了一种重载标准python操作符的机制

- 二元操作符

```
一系列魔法方法可用于重载python中的多种二元操作符，如+和-等。实际上对于每一个操作符，python都提供了3种魔法方法，每种方法都接受两个位置参数(self,other)
1. 普通方法(vanilla method)
表达式x+y与x.__add__(y)匹配，这类方法仅仅返回结果
2. 取反方法(reverse method)
只有在第一个操作对象不提供传统方法并且操作对象类型不同(返回NotImplemented)时才调用取反(操作符两边顺序交换)。
这两类方法的拼写机制相同，只是取反方法在方法名称的开头加上了r，因此，对于表达式x+y,若x没有定义__add__方法，则调用y.__radd__(x)
3. 即席方法(in-place method)
在操作符即席修改第一个变量时被调用(如+=，-=)。即席方法与第一类方法的拼写机制相同，只是这类方法仅仅是在正常方法开头加了i。因此表达式x+=y将会调用x.__iadd__(x)
通常，即席方法仅仅即席修改self并返回它。但这并不是严格的需求。值得注意的是，仅在直接方法没有清晰匹配的情况下，才需要定义一个即席方法。若未定义即席方法，则会调用直接方法将值赋值给操作符左边的对象并返回
```
操作符重载的魔法方法

| 操作符 | 方法           | 取反            | 即席            |
| ------ | -------------- | --------------- | --------------- |
| +      | `__add__`      | `__radd__`      | `__iadd__`      |
| -      | `__sub__`      | `__rsub__`      | `__isub__`      |
| *      | `__mul__`      | `__rmul__`      | `__imul__`      |
| /      | `__truediv__`  | `__rtruediv__`  | `__itruediv__`  |
| //     | `__floordiv__` | `__rfloordiv__` | `__ifloordiv__` |
| %      | `__mod__`      | `__rmod__`      | `__imod__`      |
| **     | `__pow__`      | `__rpow__`      | `__ipow__`      |
| &      | `__and__`      | `__rand__`      | `__iand__`      |
| \|     | `__or__`       | `__ror__`       | `__ior__`       |
| ^      | `__xor__`      | `__rxor__`      | `__ixor__`      |
| `<<`   | `__lshift__`   | `__rlshift__`   | `__ilshift__`   |
| `>>`   | `__rshift__`   | `__rrshift__`   | `__irshift__`   |

除法

```python
最初，在python中的两个int型数据进行除法运算。返回值类型为int，而不是float。基本原理是两个数进行除法运算然后向下取整。若是希望得到float数据类型的结果，则至少需要其中一个值的类型是float
python3中修改了该特征，对两个Int类型数据做除法返回float类型的数据，即使结果是整数也是如此。
在python2的后续版本中，特殊模块__future__用于倒入未来特征，在2.6和2.7中，通过加入from __future__ import division来可选python3特征

python3中使用__truediv__(同类方法)，当引入future时，python2也执行__truediv__(同类方法)
通常，在python2中执行的代码最终如何处理除法并不可知，需要同时定义__truediv__和__div__
或许使用__truediv__且将__div__作为别名
# 如下时可行的
class MyClass(object):
    def __truediv__(self, other):
        [...]
    __div__ = __truediv__  
```

- 一元操作符

+,-,~

+和-即是一元操作符也是二元操作符。解释器可以根据表达式确定操作符被用于一元还是二元
只接受一个位置参数(self)，执行操作并返回结果。三个方法的名称分别为`__pos__(+)`,`__neg__(-)`,`__invert__(~)`

表达式~x，就是调用`x.__invert__()`

```python
# 仿string类
class ReversibleString(object):
    def __init__(self, s):
        self.s = s
        
    def __invert__(self):
        return self.s[::-1]
    
    def __str__(self):
        return self.s
    
rs = ReversibleString('hi')
print(~rs)  # rs变量并未被赋值，输出是str对象

# 另一种
class ReversibleString(object):
    def __init__(self, s):
        self.s = s
        
    def __invert__(self):
        return type(self)(self.s[::-1])
    
    def __repr__(self):
        return 'ReversibleString: %s' % self.s
    
    def __str__(self):
        return self.s
    
rs = ReversibleString('hi')
print(~rs)  # 输出对象是ReversibleString，可以被多次逆序
print(~rs)  # 调用了rs对象的__invert__方法，然后对表达式结果再次调用__invert__方法
```

#### 重载常见方法

python包含了很多内置方法，被广泛使用并将对象作为操作符。因此，python提供了对象传递到这些方法时被调用的魔法方法

```python
__len__
# 确定一个条目的长度,接受位置参数(self)并返回一个整型值
# 通常还被用于确定对象被类型转换为bool或用于if语句时，其值是True还是False，除非对象定义了__bool__(python2中__mozero__)
class Timespan(object):
    def __init__(self, hours=0, minutes=0, seconds=0):
		self.hours = hours
		self.minutes = minutes
        self.seconds = seconds
        
    def __len__(self):
        return (self.hours * 3600) + (self.minutes * 60) + self.seconds
    
ts = Timespan(hours=2, minutes=30, seconds=1)
len(ts)
bool(ts)
bool(Timespan(hours=0, minutes=0, seconds=0))

__repr__
# 用于确定对象载python交互式终端中的显示方式，接受一个位置参数(self)
# 未创建时，默认情况下，打印对象调用__str__
# 若重写了__repr__魔法方法，会打印这个方法返回的字符串，作为这个对象的描述信息
# 若直接输出，也输出对象的描述信息
# 与str区别取决于读取内容的不同，repr给程序员读，str给普通用户
class Timespan(object):
    def __init__(self, hours=0, minutes=0, seconds=0):
		self.hours = hours
		self.minutes = minutes
        self.seconds = seconds
        
    def __repr__(self):
        return 'Timespan(hours=%d, minutes=%d, seconds=%d)'%(self.hours, self.minutes, self.seconds)
# 在终端上
>>> Timespan()

__hash__
# 通过数字化表达式唯一标识对象
# 当一个对象传递给散列函数时，调用其__hash__方法。接受一个位置参数(self)，返回一个整型值，可以负数
# 对象类提供了__hash__函数，通常返回该对象的id，对象的id值是与实现方式具体相关的，在CPython中，该值是其内存地址
# 若是定义了__eq__方法，则__hash__方法会隐式地被赋值为None。这样做是由于通常哈希值的目的很模糊。取决于对象的使用方式，每一个对象拥有哈希值且保持唯一是最佳实践，并且相等的对象其哈希值也应该相等
# 若一个类能够理解相等且可哈希化时，其必须显式定义一个__hash__方法
# 最常用处于字典的键值与set对象。仅有可哈希的对象可以作为字典的键值和在set对象中存在，为了可以确定查找

__format__
# 根据python的格式化规范来格式化不同种类的对象
# 在对象被传递到format时调用，接受两个位置参数，第一个为self，第二个是格式化规范的字符串
# 在python3中，str.format方法倾向使用__format__方法替换%操作来处理字符串内的占位符
from datetime import datetime

class MyDate(datetime):
    def __format__(self, spec_str):
		if not spec_str:
            spc_str = '%Y-%m-%d %H:%M:%S'
        return self.strtime(spec_str)
    
md = MyDate(2012, 4, 21, 11)
'{0}'.format(md)

__instancecheck__,__subclasscheck__
# python2.6引入，可以伪装类身份，极少需要自定义
# 接受两个参数，第一个是self，第二个是用于比较的类，允许类决定哪个对象可能会伪装成其实例或子类
# 内置的isinstance方法检查一个对象是否是某个类的实例，issubclass检查一个类是否继承于另一个类，若是则都返回True，若不是则返回False


__abs__,__round__
# 分别用于返回绝对值于取整后的值，很少需要自定义
# 接受一个位置参数self,返回一个数字类型的值
```

#### 集合

很多对象都是其他不同种类对象的集合。最复杂的类功能上是来自属性的集合(以某种有意义的方式排列)与对象中定义的方法集合

python通过几种方式来理解一个对象与另外一个对象是否为"成员关系"。

```
对于列表和字典，通过needle in haystack检查一个对象是否是一个集合的成员
字典由键组成，且可以通过haystack[key]基于键进行查找。
大多数对象拥有属性，这些属性在初始化时设置或通过其他方法设置，可以使用点操作符访问(haystack.attr_name)
```

python提供了与所有这些对象交互的魔法方法

```python
__contains__
# 在对表达式求值(needle in saystack)被调用
# 接受两个位置参数(self, needle),若needle在集合中，返回True，否则返回False
# 该方法并不能严格确保某一对象在一个集合中，虽然常用语此情况
class DataRange(object):
    """表示一段时间区间"""
    def __init__(self, start, end):
        self.start = start
        self.end = end
    def __contains__(self, needle):
        return self.start <= neddle <= self.end

dr = DataRange(date(2015, 1, 1), date(2015, 12, 31))
print(date(2015, 4, 21) in dr)
print(date(2012, 4, 21) in dr)

__getitem__,__setitem__,__delitem__
# 此类方法用于对集合(如字典)，索引或部分集合(如列表)进行键查找，基本表达式式haystack[key]
# __getitem__方法接受两个参数，self,key。该方法在集合能找到元素时返回对应值，否则引发对应的异常，引发一场取决于具体情况，但通常都是IndexError,keyError,TypeError
# __setitem__方法接受三个位置参数，self,key,value。用于设置集合元素的值。并非所有支持元素查找的对象也同时支持元素修改。若需要，可以在定义__getitem__下不定义__setitem__
# __delitem__方法在使用del关键字(del haystack[key])时被调用。

__getattr__,__setattr__
# python类用作集合的另一种方式时作为属性与对象的集合。当date对象包含year、month、day时，这些都是属性
# 无论是通过点(obj.attr_name)还是getattr方法(getattr(obj, 'attr_name)),__getattr__方法都会在试图获取一个对象的属性时被调用。但是解释器先进行标准的属性查找，若是发现则返回，若没有匹配属性(AttributeError),才会调用__getattr__方法。接受两个位置参数(self,key)，返回合适的值，或是引发AttributeError
# __setattr__方法用在赋值一个对象时被调用，无论是通过点操作符还是setattr方法。与__getattr__不同的是，该方法一直会被调用(否则无存在意义)，因此，若希望使用传统实现，应该调用基类方法

__getattribute__
# 只有在无法找到属性时才被调用，引起这是在常规情况下希望的行为(否则会易陷入无限循环的大坑)。然而，与__getattr不同，__getatrribute__会被无条件调用

逻辑顺序时首先调用__getattribute__,在正常情况下负责执行系统的属性查找。若类定义了__getattribute__，其变为负责调用基类的实现。如果(且只有在这种情况下)__getattribute__引发AttributeError异常，调用__getattr__方法
```

### 其他

```
# __dict__:类的属性(一个字典，由类的数据属性组成)，对象的属性
# __doc__:类的文档字符串，若无定义为None
# __name__:类的名字
# __module__:类定义所在的模块名称，交互模式其值为__main__
# __class__:当前操作的对象所在的类的名称，与内置type()一致
# __base__: 返回包含该类的所有基类的元组
# __subclasses__()：返回该类的所有子类

# __init__：初始化方法，通过类创建对象时，自动触发执行
# __del__:当对象在内存中被释放时，自动触发执行。
#  __str__:那么在打印对象时，默认输出该方法的返回值，默认是类对象
# __call__：对象后面加括号，触发执行
# __getitem__：用于索引操作获取数据，如字典
# __setitem__：用于索引操作设置数据，如字典
# __delitem__：用于索引操作删除数据，如字典
# __getslice__：分片操作获取数据，如：列表
# __setslice__：分片操作设置数据，如：列表
# __delslice__：分片操作删除数据，如：列表

# __iter__和__next__实现迭代协议
# __enter__和__exit__实现上下文管理器
```

**详解**

```
# __iter__()
# 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。
# 以斐波那契数列为例，写一个Fib类，可以作用于for循环：
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
# 把Fib实例作用于for循环：
for n in Fib():
    print(n)
     
     
# __getitem__()
正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错
要避免这个错误，除了可以加上一个属性外，Python还有另一个机制，那就是写一个__getattr__()方法，当调用不存在的属性时，动态调用__getattr__()方法返回一个属性。

# 示例
很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：
http://api.server/user/friends
http://api.server/user/timeline/list
如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。
利用完全动态的__getattr__，我们可以写出一个链式调用：
class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__
# 调用(无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！)
>>> Chain().status.user.timeline.list
'/status/user/timeline/list'


# __call__()
一个对象实例不仅可以instance.method()调用，还可以直接在实例本身上调用instance()
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
```

# 使用枚举类

```
# Python提供了Enum类实现了：枚举类型定义一个class类型，每个常量都是class的一个唯一实例

from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

# 使用Month.Jan来引用一个常量，或者枚举它的所有成员
for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value)
value属性则是自动赋给成员的int常量，默认从1开始计数。
```

# 使用元类

在python中，type是一个特殊的类，可以看做所有类型(包括object)的基类。

