# 正则表达式

正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。

## 匹配单个字符

| 字符 | 功能                             |
| ---- | -------------------------------- |
| .    | 匹配任意1个字符（除了\n）        |
| [ ]  | 匹配[ ]中列举的字符              |
| \d   | 匹配数字，即0-9                  |
| \D   | 匹配非数字，即不是数字           |
| \s   | 匹配空白，即 空格，tab键         |
| \S   | 匹配非空白                       |
| \w   | 匹配单词字符，即a-z、A-Z、0-9、_ |
| \W   | 匹配非单词字符                   |

## 匹配多个字符

| 字符  | 功能                                                |
| ----- | --------------------------------------------------- |
| *     | 匹配前一个字符出现0次或者无限次，即可有可无         |
| +     | 匹配前一个字符出现1次或者无限次，即至少有1次        |
| ?     | 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 |
| {m}   | 匹配前一个字符出现m次                               |
| {m,n} | 匹配前一个字符出现从m到n次                          |

## 匹配开头结尾

| 字符 | 功能           |
| ---- | -------------- |
| ^    | 匹配字符串开头 |
| $    | 匹配字符串结尾 |

## 匹配分组

| 字符         | 功能                             |
| ------------ | -------------------------------- |
| \|           | 匹配左右任意一个表达式           |
| (ab)         | 将括号中字符作为一个分组         |
| `\num`       | 引用分组num匹配到的字符串        |
| `(?P<name>)` | 分组起别名                       |
| (?P=name)    | 引用别名为name分组匹配到的字符串 |

#python中使用

```
Python提供re模块，包含所有正则表达式的功能。由于Python的字符串本身也用\转义，所以要使用r前缀，就不用考虑转义的问题了
```

## 对象

```
re.RegexObject
re.compile() 返回 RegexObject 对象。

re.MatchObject
group() 返回被 RE 匹配的字符串。

start() 返回匹配开始的位置
end() 返回匹配结束的位置
span() 返回一个元组包含匹配 (开始,结束) 的位置
```

## 修饰符

正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：

| 修饰符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| re.I   | 使匹配对大小写不敏感                                         |
| re.L   | 做本地化识别（locale-aware）匹配                             |
| re.M   | 多行匹配，影响 ^ 和 $                                        |
| re.S   | 使 . 匹配包括换行在内的所有字符                              |
| re.U   | 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.      |
| re.X   | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |

##匹配

###match

re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。

```
# 语法
re.match(pattern, string, flags=0)

# 参数
pattern	匹配的正则表达式
string	要匹配的字符串。
flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

# 实例
>>> import re
>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
>>>
```

###search

re.search 扫描整个字符串并返回第一个成功的匹配。

```
# 语法
re.search(pattern, string, flags=0)

# 参数
pattern	匹配的正则表达式
string	要匹配的字符串。
flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

# 实例
>>>import re
>>>ret = re.search(r"\d+", "阅读次数为 9999")
>>>ret.group()
'9999'
```

###findall

在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。

**注意：** match 和 search 是匹配一次 findall 匹配所有。

```
# 语法
findall(string[, pos[, endpos]])

# 参数
tring 待匹配的字符串。
pos 可选参数，指定字符串的起始位置，默认为 0。
endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。

# 实例
>>>import re
>>>ret = re.findall(r"\d+", "python = 9999, c = 7890, c++ = 12345")
>>>print(ret)
['9999', '7890', '12345']
```

### finiter

在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。

```
# 语法
re.finditer(pattern, string, flags=0)

# 参数
pattern	匹配的正则表达式
string	要匹配的字符串。
flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

# 实例
import re 
it = re.finditer(r"\d+","12a32bc43jf3") 
for match in it: 
    print (match.group() )
```

## 替换

### sub

用于替换字符串中的匹配项。

```
# 语法
re.sub(pattern, repl, string, count=0)

# 参数
pattern : 正则中的模式字符串。
repl : 替换的字符串，也可为一个函数。
string : 要被查找替换的原始字符串。
count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。

# 实例
>>>import re
>>>ret = re.sub(r"\d+", '998', "python = 997")
>>>print(ret)
python = 998
```

##分割

### split

split 方法按照能够匹配的子串将字符串分割后返回列表

```
# 语法
re.split(pattern, string[, maxsplit=0, flags=0])

# 参数
pattern	匹配的正则表达式
string	要匹配的字符串。
maxsplit	分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。
flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

# 实例
# 正常切分代码
>>> 'a b   c'.split(' ')
['a', 'b', '', '', 'c']

# 使用正则表达式
>>> re.split(r'\s+', 'a b   c')
['a', 'b', 'c']
>>> re.split(r'[\s\,]+', 'a,b, c  d')
['a', 'b', 'c', 'd']
>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
```

## 分组

| 匹配对象方法 | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| group(num=0) | 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 |
| groups()     | 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。     |

```
# 正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）,

# group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。

>>> m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
>>> m
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'
```

## 贪婪匹配

正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的`0`

```
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')
```

在"*","?","+","{m,n}"后面加上？，使贪婪变成非贪婪。

```
>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')
```

## 编译

当我们在Python中使用正则表达式时，re模块内部会干两件事情：

- 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
- 用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：

compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。

```
# 语法
re.compile(pattern[, flags])

# 参数
pattern : 一个字符串形式的正则表达式
flags 可选，表示匹配模式，比如忽略大小写，多行模式等

# 实例
>>> import re
# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')
```



