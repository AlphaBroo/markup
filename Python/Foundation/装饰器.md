[TOC]

# 装饰器

概念

```
装饰器是一个用于封装函数或类的代码工具，它显式地将封装器应用到函数或类上，从而使它们选择加入到装饰器的功能中
装饰器就是一个可以接受调用也可以返回调用的调用。
装饰器是一个函数(或调用，如有__call_method__方法的对象)，该函数接受被装饰的函数作为其位置参数，装饰器通过使用该参数来执行某些操作，然后返回原始参数或一些其他的调用
由于函数在python中是一级对象，故它们能够像其他对象一样被传递到另一个函数
```

语法

```python
# 原始
def decorated_by(func):
    func.__doc__ += '\nDecorated by decorated_by'
    return func

def add(x, y):
    "return the sum of x and y"
    return x + y

add = decorated_by(add)

# 语法糖
def decorated_by(func):
    func.__doc__ += '\nDecorated by decorated_by'
    return func

@decorated_by
def add(x, y):
    "return the sum of x and y"
    return x + y
```

应用顺序

```
多层装饰器，若使用@语法，则需要按照自底向上的顺序应用它们
```

装饰器应用

```python
# python标准库
@classmethod	# 使一个类上的方法不需要这个类的实例
@staticmethod	# 使一个类上的方法不需要这个类的实例
@mock.patch
@mock.patch.object
# Django
@login_required	 # 登陆权限验证
# Flask
@app.route  # 指定的URI与浏览器访问这些URI时所运行的函数之间的注册表
# Celery
@task		# 标示函数是否为异步任务，实际上返回Task类的实例，用来阐明如何使用装饰器制作一个方便的API
```

编写装饰器的时机

```
1. 附加功能
在执行被装饰方法之前或之后添加额外的功能。包括检查身份、将函数结果记录到固定位置等

2. 数据的清理或添加
修正传递给被装饰函数的参数值
改变或清除从函数中返回的数据
为函数提供额外的数据，如附加参数

3.函数注册
在其他位置注册函数，如在任务运行器中注册一个任务，或者注册一个带有信号处理器的函数。任何由外部输入或路由机制决定函数运行的系统都可以使用函数注册
```

参数

```
装饰器的参数在函数声明并被装饰时处理一次
函数的参数在该函数被调用时处理

装饰器又个隐式参数-被装饰的方法
```



## 函数装饰器

### 不带参数装饰函数

```python
def set_func(func):
    print(000000000)
    # 定义函数形参，选择不定长形参(*args为元组，*kwargs为字典)
    def call_func(*args, **kwargs):
        print(222222)
        # 拆包，若不拆包，则传参为元组和字典
        ret = func(*args, **kwargs)
        print(333333)
        return ret
    print(1111111)
    return call_func

@set_func
def test():
    """无参数无返回值的函数"""
    print('无参无返')

@set_func
def test1(num):
    """有参数无返回值"""
    print('有参无返---num=%d' % num)

@set_func
def test2():
    """无参数有返回值"""
    print('无参有返')
    return 10

@set_func
def test3(num):
    """有参数有返回值"""
    print('有参有返---num=%d' % num)
    return 10,20

test()
test1(1)
print(test2())
print(test3(2))
```
### 多层装饰函数

装饰器的应用顺序：自底向上

```python
def set_func1(func1):
    print(00000000)
    def call_func1():
        print(222222)
        func1()
        print(333333)
    print(111111)
    return call_func1

def set_func2(func2):
    print('xxxxxx')
    def call_func2():
        print(444444)
        func2()
        print(555555)
    print('yyyyyy')
    return call_func2

@set_func1
@set_func2
def test():
    print('hihi')

test()

# 装饰@set_func2，执行set_func2()函数，test指向call_func2,func2指向原test
# 装饰@set_func1, 执行set_func1()函数，test指向call_func1,func1指向call_func2
# test(),后调用call_func1(),call_func2(),test(),
```

### 装饰类

```python
# 定义函数来装饰类
def abc(myclass):
  # 定义内嵌类
  class InnerClass:
    def __init__(self,z=0):
      self.z = z
      self.wrapper = myclass()
      
    def position(self):
      self.wrapper.position()
      print('z axis:',self.z)
  return InnerClass
  
  
@abc 
class Coordination:
  def __init__(self,x=0,y=0):
	self.x = x
    self.y = y
    
  def position(self):
    print('x axis:',self.x)
    print('y axis:',self.y)
    
if __name__ == '__main__':
  coor = Coordination()
  coor.position()  
```

### 带参数装饰函数

```python
def set_level(num):
    def set_func(func):
        # 定义函数形参，选择不定长形参(*args为元组，*kwargs为字典)
        def call_func(*args, **kwargs):
            # 拆包，若不拆包，则传参为元组和字典
            ret = func(*args, **kwargs)
            return ret, num
        return call_func
    return set_func

@set_level(1)
def do_nothing():
    return 'a'
```
## 类装饰器

### 不带参数装饰函数

```python
class Log(object):
    def __init__(self,func):
        self.func = func

    def __call__(self):
        print('hi')
        self.func()

@Log  # test=Log(test)
def test():
    print('---test---')

test()
```
### 带参数装饰函数 

```python
class Log(object):
    def __init__(self,num):
        pass

    def __call__(self,func):
        print('1111')
        def call_func():
            print('2222')
            func()
        return call_func


@Log(1)  # a = Log(1)  test = a(test)
def test():
    print('---test---')

test()
```

## 装饰后不变函数名

```python
# 方法一：
wrapper.__name__ = func.__name__

# 方法二：
在定义wrapper()的前面加上@functools.wraps(func)

# 无参数
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper

# 有参数
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

 