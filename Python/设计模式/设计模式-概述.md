# 设计模式

```
Christopher Alexander：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样你就能一次又一次地使用该方案而不必做重复劳动。”

设计模式是经过总结、优化的，对我们经常会碰到的一些编程问题的可重用解决方案。一个设计模式并不像一个类或一个库那样能够直接作用于我们的代码。反之，设计模式更为高级，它是一种必须在特定情形下实现的一种方法模板。设计模式不会绑定具体的编程语言。最为重要的是，设计模式也是一把双刃剑，如果设计模式被用在不恰当的情形下将会造成灾难，进而带来无穷的麻烦。然而如果设计模式在正确的时间被用在正确地地方，它将是你的救星。

可以通过程序设计的基本概念来理解模式：增加一个抽象层。抽象一个事物就是隔离任何具体细节，这么做的目的是为了将那些不变的核心部分从其他细节中分离出来。当你发现你程序中的某些部分经常因为某些原因改动，而你不想让这些改动的部分引发其他部分的改动，这时候你就需要思考那些不会变动的设计方法了。这么做不仅会使代码可维护性更高，而且会让代码更易于理解，从而降低开发成本。
```

# 分类


## 创建型

```
创建模式，提供实例化的方法，为适合的状况提供相应的对象创建方法。

创建型
PaymentFactory(简单工厂)
Factory Method（工厂方法）
Abstract Factory（抽象工厂）
Builder（建造者）
Prototype（原型）
Singleton（单例）

使用抽象工厂（Abstract Factory）、原型（Prototype）或者建造者（Builder）的设计甚至比工厂方法（Factory Method）的那些设计更灵活，但它们也更加复杂。通常，设计以使用工厂方法（Factory Method）开始。并且当设计者发现需要更大的灵活性时，设计便会想其他创建模式烟花。当你在设计标准之间权衡的时候，了解多个模式可以给你提供给更多的选择余地。

依赖于继承的创建型模式：工厂方法模式

依赖于组合的创建型模式：抽象工厂模式、创建者模式
```

## 结构式

```
结构化模式，通常用来处理实体之间的关系，使得这些实体能够更好地协同工作。

结构型
Adapter Class/Object（适配器）
Bridge（桥接）
Composite（组合）
Decorator（装饰）
Facade（外观）
Flyweight（享元）
Proxy（代理）
```

## 行为式

```
行为模式，用于在不同的实体建进行通信，为实体之间的通信提供更容易，更灵活的通信方法。

行为型
Interpreter（解释器）
Template Method（模板方法）
Chain of Responsibility（责任链）
Command（命令）
Iterator（迭代器）
Mediator（中介者）
Memento（备忘录）
Observer（观察者）
State（状态）
Strategy（策略）
Visitor（访问者）
```

# 六大原则

```
开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

里氏（Liskov）替换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。

依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。换言之，要针对接口编程，而不是针对实现编程。

接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。

单一职责原则：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。
```

# 接口

接口：一种特殊的类，声明了若干方法，要求继承该接口的类必须实现这些方法。
作用：限制继承接口的类的方法的名称及调用方式；隐藏了类的内部实现。

接口就是一种抽象的基类（父类），限制继承它的类必须实现接口中定义的某些方法。

Python中使用ABCMeta、abstractmethod的抽象类、抽象方法来实现接口的功能。接口类定义方法，不具体实现，限制子类必须有该方法。在接口子类中实现具体的功能。

```
# 通过抽象类和抽象方法，做抽象用
from abc import ABCMeta
from abc import abstractmethod  # 导入抽象方法

class Father(metaclass=ABCMeta):  # 创建抽象类
    
    @abstractmethod
    def f1(self):
        pass

    @abstractmethod
    def f2(self):
        pass

class F1(Father):
    def f1(self):
        pass

    def f2(self):
        pass

    def f3(self):
        pass

obj = F1()
```





