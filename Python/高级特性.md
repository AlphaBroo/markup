# 迭代

```
如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。

在Python中，迭代是通过for ... in来完成的，而很多语言比如C语言，迭代list是通过下标完成的

Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。

# 判断是够可迭代对象
from collections import Iterable
isinstance(对象, Iterable)

for ch in 'abc':
	print(ch)
	
for value in ['A', 'B', 'c']:
	print(value)

for i, v in enumerate(['A', 'B', 'C']):
	print(i, v)
	
for key in {'a': 1, 'b': 2}:
	print(key)

for value in {'a': 1, 'b': 2}.values():
	print(key)

for for k, v in {'a': 1, 'b': 2}.items():
	print(k, v)	

for x, y in [(1, 1), (2, 4), (3, 9)]:
    print(x, y)
```

# 列表生成式

```
列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。

list(range(1, 5))	--->[1, 2, 3, 4]
[x * x for x in range(1, 5)]	--->[1, 4, 9, 16]
[x * x for x in range(1, 11) if x % 2 == 0]	--->[4, 16, 36, 64, 100]
[m + n for m in 'ABC' for n in 'XYZ']	--->['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
```

# 生成器

```
通过列表生成式，我们可以直接创建一个列表。但是受到内存限制，列表容量肯定是有限的。
在Python中，这种一边循环一边计算的机制，称为生成器：generator。

# 创建生成器方法一：列表生成式的[]改成()
g = (x * x for x in range(10))

# 创建生成器方法二：函数定义中包含yield关键字
# generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'

# 获得生成器的下一个返回值，没有更多的元素时，抛出StopIteration的错误
 next(g)
# 获取生成器返回值常用方法：for循环
for n in g:
	print(n)
	
for n in fib(6):
	print(n)
```

# 迭代器

```
Python的Iterator对象表示的是一个数据流，
是一个可以记住遍历的位置的对象，从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。

Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。


# 判断是否是迭代器
from collections import Iterator
isinstance(对象, Iterator)

直接作用于for循环的数据类型有以下几种：
一类是集合数据类型，如list、tuple、dict、set、str等；
一类是generator，包括生成器和带yield的generator function。

凡是可作用于for循环的对象都是Iterable类型
凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列

集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter(对象)函数获得一个Iterator对象

Python的for循环本质上就是通过不断调用next()函数实现的

for x in [1, 2, 3, 4, 5]:
    pass
# 等价于：
it = iter([1, 2, 3, 4, 5])	# 获得Iterator对象
while True:
    try:
        x = next(it)	# 获得下一个值:
    except StopIteration:        
        break	# 遇到StopIteration就退出循环
```

